class t { text = ""; cursor = 0; line = 1; column = 1; #t = { cursor: 0, line: 1, column: 1 }; constructor(t) { this.text = t } read(e = 1) { let i = "", s = this.cursor; for (let t = 0; t < e; t += 1) { var r = this.text[s + t]; if (void 0 === r) break; i += r, this.cursor += 1, "\n" === r ? (this.line += 1, this.column = 1) : this.column += 1 } return "" === i ? null : i } peek(e = 1) { let i = ""; for (let t = 0; t < e; t += 1) { var s = this.text[this.cursor + t]; if (void 0 === s) break; i += s } return "" === i ? null : i } eatSpaces() { let t = ""; for (; " " === this.peek();)t += this.read(); return t } eatWhitespace() { let t = ""; for (; " " === this.peek() || "\n" === this.peek();)t += this.read(); return t } storePosition() { var { cursor: t, line: e, column: i } = this; this.#t = { cursor: t, line: e, column: i } } restorePosition() { var { cursor: t, line: e, column: i } = this.#t; this.cursor = t, this.line = e, this.column = i } } let { max: e, pow: i, sqrt: s, PI: n } = Math, o = (t, e = 0) => { e = i(10, e); return Math.round(t * e) / e }, r = (t, e = 0) => new DOMRect(o(t.x, e), o(t.y, e), o(t.width, e), o(t.height, e)), h = (t, e, i = 1 / 0, s = null) => ((t = null !== s ? o(t, s) : t) < e ? t = e : i < t && (t = i), t), a = i => { if (isFinite(i)) { let t = 1, e = 0; for (; Math.round(i * t) / t !== i;)t *= 10, e += 1; return e } return 0 }, l = (t, e) => { var i = e.x - t.x, e = (i *= i, e.y - t.y); return e *= e, s(i + e) }, { min: d, max: u, floor: c, pow: p, atan2: m, PI: g, sqrt: b } = Math, f = (t, e, i) => { let s, r, n, a = u(t /= 255, e /= 255, i /= 255), o = d(t, e, i); var l; return s = r = n = (a + o) / 2, a === o ? s = r = 0 : (l = a - o, r = .5 < n ? l / (2 - a - o) : l / (a + o), a === t ? s = (e - i) / l + (e < i ? 6 : 0) : a === e ? s = (i - t) / l + 2 : a === i && (s = (t - e) / l + 4)), s = h(s / 6 * 360, 0, 360, 0), r = h(100 * r, 0, 100, 1), n = h(100 * n, 0, 100, 1), [s, r, n] }, x = (t, e, i) => { let s, r, n; var a; return t /= 360, i /= 100, 0 == (e /= 100) ? s = r = n = i : (a = (t, e, i) => (i < 0 && (i += 1), 1 < i && --i, i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t), e = 2 * i - (i = i < .5 ? i * (1 + e) : i + e - i * e), s = a(e, i, t + 1 / 3), r = a(e, i, t), n = a(e, i, t - 1 / 3)), s = h(255 * s, 0, 255, 0), r = h(255 * r, 0, 255, 0), n = h(255 * n, 0, 255, 0), [s, r, n] }, w = (t, e, i) => { e /= 100, i /= 100; let s = c(6 * (t /= 360)), r = 6 * t - s, n = i * (1 - e), a = i * (1 - r * e), o = i * (1 - (1 - r) * e), l = 0, h = 0, d = 0; return s % 6 == 0 ? (l = i, h = o, d = n) : s % 6 == 1 ? (l = a, h = i, d = n) : s % 6 == 2 ? (l = n, h = i, d = o) : s % 6 == 3 ? (l = n, h = a, d = i) : s % 6 == 4 ? (l = o, h = n, d = i) : s % 6 == 5 && (l = i, h = n, d = a), l *= 255, h *= 255, d *= 255, [l, h, d] }, v = (a, o = "rgba", l = "hex") => { let c = null; if (["rgb", "rgba", "rgb%", "rgba%", "hex"].includes(l)) { let s, r, n, t; if ("rgba" === o ? [s, r, n, t] = a : "hsla" === o ? ([s, r, n] = x(...a), t = a[3]) : "hsva" === o && ([s, r, n] = w(...a), t = a[3]), t = (n = "rgb%" === l || "rgba%" === l ? (s = h(s / 255 * 100, 0, 100, 1), r = h(r / 255 * 100, 0, 100, 1), h(n / 255 * 100, 0, 100, 1)) : (s = h(s, 0, 255, 0), r = h(r, 0, 255, 0), h(n, 0, 255, 0)), h(t, 0, 1, 2)), "rgb" === l) c = `rgb(${s}, ${r}, ${n})`; else if ("rgba" === l) c = `rgba(${s}, ${r}, ${n}, ${t})`; else if ("rgb%" === l) c = `rgb(${s}%, ${r}%, ${n}%)`; else if ("rgba%" === l) c = `rgb(${s}%, ${r}%, ${n}%, ${t})`; else if ("hex" === l) { let t = s.toString(16), e = r.toString(16), i = n.toString(16); 1 === t.length && (t = "0" + t), 1 === e.length && (e = "0" + e), 1 === i.length && (i = "0" + i), c = "#" + t + e + i } } else if ("hsl" === l || "hsla" === l) { let t, e, i, s; "hsla" === o ? [t, e, i, s] = a : "hsva" === o ? ([t, e, i] = ((t, e, i) => { let s = t /= 360, r = (2 - (e /= 100)) * (i /= 100), n = e * i; return r <= 1 ? 0 === r ? n = 0 : n /= r : 2 === r ? n = 0 : n /= 2 - r, r /= 2, s *= 360, n = 100 * u(0, d(1, n)), r = 100 * u(0, d(1, r)), [s, n, r] })(...a), s = a[3]) : "rgba" === o && ([t, e, i] = f(...a), s = a[3]), t = h(t, 0, 360, 0), e = h(e, 0, 100, 1), i = h(i, 0, 100, 1), s = h(s, 0, 1, 2), "hsl" === l ? c = `hsl(${t}, ${e}%, ${i}%)` : "hsla" === l && (c = `hsla(${t}, ${e}%, ${i}%, ${s})`) } return c }, y = (t, e) => { var i = e.startsWith("hsl") ? "hsla" : "rgba", t = (new E).parse(t, i); return v(t, i, e) }, k = t => { if ("#" !== (t = t.toLowerCase())[0]) return !1; if (4 !== t.length && 7 !== t.length) return !1; let e = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"]; for (var i of t = t.substring(1)) if (!e.includes(i)) return !1; return !0 }, z = () => new Promise(n => { if (z.url) n(z.url); else if (z.callbacks) z.callbacks.push(n); else { z.callbacks = [n]; let t = document.createElement("canvas"), e = t.getContext("2d"), i = e.createImageData(300, 300), s = i.data, r = 0; t.width = 300, t.height = 300; for (let e = 0; e < 300; e++)for (let t = 0; t < 300; t++) { var a = t - 150, o = e - 150, l = p(a, 2) + p(o, 2), o = (m(o, a) + g) / (2 * g) * 360, a = b(l) / 150 * 100, [o, a, h] = w(o, a, 100), l = l > p(150, 2) ? 0 : 255; s[r++] = o, s[r++] = a, s[r++] = h, s[r++] = l } e.putImageData(i, 0, 0), t.toBlob(t => { z.url = URL.createObjectURL(t); for (var e of z.callbacks) e(z.url) }) } }), { parseFloat: C, parseInt: S } = Number; class E { static #e = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }; parse(t, e = "rgba") { t = t.trim(); let r = this.#i(t), n = null, i = null; if (7 === r.length && "rgb(" === r[0].text && "NUM" === r[1].type && "," === r[2].text && "NUM" === r[3].type && "," === r[4].text && "NUM" === r[5].type && ")" === r[6].text) n = [C(r[1].text), C(r[3].text), C(r[5].text), 1]; else if (7 === r.length && "rgb(" === r[0].text && "PERCENTAGE" === r[1].type && "," === r[2].text && "PERCENTAGE" === r[3].type && "," === r[4].text && "PERCENTAGE" === r[5].type && ")" === r[6].text) n = [C(r[1].text) / 100 * 255, C(r[3].text) / 100 * 255, C(r[5].text) / 100 * 255, 1]; else if (9 === r.length && "rgba(" === r[0].text && "NUM" === r[1].type && "," === r[2].text && "NUM" === r[3].type && "," === r[4].text && "NUM" === r[5].type && "," === r[6].text && "NUM" === r[7].type && ")" === r[8].text) n = [C(r[1].text), C(r[3].text), C(r[5].text), C(r[7].text)]; else if (9 === r.length && "rgb(" === r[0].text && "PERCENTAGE" === r[1].type && "," === r[2].text && "PERCENTAGE" === r[3].type && "," === r[4].text && "PERCENTAGE" === r[5].type && "," === r[6].text && "NUM" === r[7].type && ")" === r[8].text) n = [C(r[1].text) / 100 * 255, C(r[3].text) / 100 * 255, C(r[5].text) / 100 * 255, C(r[7].text)]; else if (7 === r.length && "hsl(" === r[0].text && "NUM" === r[1].type && "," === r[2].text && "PERCENTAGE" === r[3].type && "," === r[4].text && "PERCENTAGE" === r[5].type && ")" === r[6].text) i = [C(r[1].text), C(r[3].text), C(r[5].text), 1]; else if (9 === r.length && "hsla(" === r[0].text && "NUM" === r[1].type && "," === r[2].text && "PERCENTAGE" === r[3].type && "," === r[4].text && "PERCENTAGE" === r[5].type && "," === r[6].text && "NUM" === r[7].type && ")" === r[8].text) i = [C(r[1].text), C(r[3].text), C(r[5].text), C(r[7].text)]; else if ("HEX" === r[0].type && void 0 === r[1]) { let t, e, i, s = r[0].text.substring(1); i = 3 === s.length ? (t = s[0] + s[0], e = s[1] + s[1], s[2] + s[2]) : (t = s[0] + s[1], e = s[2] + s[3], s[4] + s[5]), n = [S(t, 16), S(e, 16), S(i, 16), 1] } else E.#e[t] && (n = [E.#e[t][0], E.#e[t][1], E.#e[t][2], 1]); var s, a, o; if (n) return [m, s, o, a] = n, m = h(m, 0, 255, 0), s = h(s, 0, 255, 0), o = h(o, 0, 255, 0), a = h(a, 0, 1, 2), "hsla" === e ? ([l, c, p] = f(m, s, o), [l, c, p, a]) : "hsva" === e ? ([l, c, p] = ((t, e, i) => { let s = u(t /= 255, e /= 255, i /= 255), r = d(t, e, i), n = 0, a, o = s, l = s - r; return a = 0 === s ? 0 : l / s, s === r ? n = 0 : (s === t ? n = (e - i) / l + (e < i ? 6 : 0) : s === e ? n = (i - t) / l + 2 : s === i && (n = (t - e) / l + 4), n /= 6), a *= 100, o *= 100, [n *= 360, a, o] })(m, s, o), [l, c, p, a]) : [m, s, o, a]; if (i) { var [l, c, p, m] = i, l = h(l, 0, 360, 0), c = h(c, 0, 100, 1), p = h(p, 0, 100, 1), m = h(m, 0, 1, 2); if ("hsla" === e) return [l, c, p, m]; if ("hsva" === e) return [e, g, b] = (s = l, s = s /= 360, e = (o = p / 100 * 2) + (a = (a = c) / 100 * (o <= 1 ? o : 2 - o)) == 0 ? 0 : 2 * a / (o + a), o = (o + a) / 2, [s *= 360, 100 * u(0, d(1, e)), 100 * u(0, d(1, o))]), [e, g, b, m]; var [e, g, b] = x(l, c, p); return [e, g, b, m] } throw new Error(`Invalid color string: "${t}"`) } #i(e) { let i = [], s = new t(e.toLowerCase()); for (; null !== s.peek();) { let e = s.read(); (() => { if ("r" === e || "h" === e) { let t = e; if (e + s.peek(3) === "rgb(" ? t += s.read(3) : e + s.peek(4) === "rgba(" ? t += s.read(4) : e + s.peek(3) === "hsl(" ? t += s.read(3) : e + s.peek(4) === "hsla(" && (t += s.read(4)), t !== e) return i.push({ type: "FUNCTION", text: t }) } if ("#" === e) { var t; if (k(e + s.peek(6))) return t = e + s.read(6), i.push({ type: "HEX", text: t }); if (k(e + s.peek(3))) return t = e + s.read(3), i.push({ type: "HEX", text: t }) } if (["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "-"].includes(e)) { let t = e; for (; ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "."].includes(s.peek());)t += s.read(); "%" === s.peek() ? (t += s.read(), i.push({ type: "PERCENTAGE", text: t })) : i.push({ type: "NUM", text: t }) } else /\u0009|\u000a|\u000c|\u000d|\u0020/.test(e) || i.push({ type: "CHAR", text: e }) })() } return i } } function A(t) { return (A = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function L(t, e) { return (L = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function M() { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0 } catch (t) { return !1 } } function T(t, e, i) { return (T = M() ? Reflect.construct : function (t, e, i) { var s = [null], e = (s.push.apply(s, e), new (Function.bind.apply(t, s))); return i && L(e, i.prototype), e }).apply(null, arguments) } function $(t) { return function (t) { if (Array.isArray(t)) return D(t) }(t) || function () { if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t) }() || function (t) { if (t) { if ("string" == typeof t) return D(t, void 0); var e = Object.prototype.toString.call(t).slice(8, -1); return "Map" === (e = "Object" === e && t.constructor ? t.constructor.name : e) || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? D(t, void 0) : void 0 } }(t) || function () { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function D(t, e) { (null == e || e > t.length) && (e = t.length); for (var i = 0, s = new Array(e); i < e; i++)s[i] = t[i]; return s } var K, R = Object.hasOwnProperty, P = Object.setPrototypeOf, I = Object.isFrozen, O = Object.getPrototypeOf, F = Object.getOwnPropertyDescriptor, B = Object.freeze, N = Object.seal, j = Object.create, H = "undefined" != typeof Reflect && Reflect, U = H.apply, q = H.construct, U = U || function (t, e, i) { return t.apply(e, i) }, B = B || function (t) { return t }, N = N || function (t) { return t }, q = q || function (t, e) { return T(t, $(e)) }, V = et(Array.prototype.forEach), X = et(Array.prototype.pop), Z = et(Array.prototype.push), G = et(String.prototype.toLowerCase), W = et(String.prototype.match), Y = et(String.prototype.replace), _ = et(String.prototype.indexOf), J = et(String.prototype.trim), Q = et(RegExp.prototype.test), tt = (K = TypeError, function () { for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)e[i] = arguments[i]; return q(K, e) }); function et(r) { return function (t) { for (var e = arguments.length, i = new Array(1 < e ? e - 1 : 0), s = 1; s < e; s++)i[s - 1] = arguments[s]; return U(r, t, i) } } function it(t, e, i) { i = i || G, P && P(t, null); for (var s = e.length; s--;) { var r, n = e[s]; "string" != typeof n || (r = i(n)) !== n && (I(e) || (e[s] = r), n = r), t[n] = !0 } return t } function st(t) { var e, i = j(null); for (e in t) U(R, t, [e]) && (i[e] = t[e]); return i } function nt(t, e) { for (; null !== t;) { var i = F(t, e); if (i) { if (i.get) return et(i.get); if ("function" == typeof i.value) return et(i.value) } t = O(t) } return function (t) { return console.warn("fallback value for", t), null } } var ot = B(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), rt = B(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), ht = B(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), at = B(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), lt = B(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), dt = B(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), ut = B(["#text"]), ct = B(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), pt = B(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), mt = B(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), gt = B(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), bt = N(/\{\{[\w\W]*|[\w\W]*\}\}/gm), ft = N(/<%[\w\W]*|[\w\W]*%>/gm), xt = N(/^data-[\-\w.\u00B7-\uFFFF]/), wt = N(/^aria-[\-\w]+$/), vt = N(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), yt = N(/^(?:\w+script|data):/i), kt = N(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), zt = N(/^html$/i), Ct = function () { return "undefined" == typeof window ? null : window }, St = function (t, e) { if ("object" !== A(t) || "function" != typeof t.createPolicy) return null; var i = null, s = "data-tt-policy-suffix", e = "dompurify" + ((i = e.currentScript && e.currentScript.hasAttribute(s) ? e.currentScript.getAttribute(s) : i) ? "#" + i : ""); try { return t.createPolicy(e, { createHTML: function (t) { return t }, createScriptURL: function (t) { return t } }) } catch (t) { return console.warn("TrustedTypes policy " + e + " could not be created."), null } }, Et = function P() { var o = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : Ct(), h = function (t) { return P(t) }; if (h.version = "2.4.0", h.removed = [], !o || !o.document || 9 !== o.document.nodeType) return h.isSupported = !1, h; var l = o.document, r = o.document, O = o.DocumentFragment, t = o.HTMLTemplateElement, d = o.Node, F = o.Element, e = o.NodeFilter, i = o.NamedNodeMap, H = void 0 === i ? o.NamedNodeMap || o.MozNamedAttrMap : i, j = o.HTMLFormElement, U = o.DOMParser, u = o.trustedTypes, i = F.prototype, K = nt(i, "cloneNode"), et = nt(i, "nextSibling"), At = nt(i, "childNodes"), c = nt(i, "parentNode"), p = ("function" != typeof t || (i = r.createElement("template")).content && i.content.ownerDocument && (r = i.content.ownerDocument), St(u, l)), Et = p ? p.createHTML("") : "", t = r, n = t.implementation, Mt = t.createNodeIterator, Lt = t.createDocumentFragment, Tt = t.getElementsByTagName, Dt = l.importNode, i = {}; try { i = st(r).documentMode ? r.documentMode : {} } catch (P) { } var s = {}; h.isSupported = "function" == typeof c && n && void 0 !== n.createHTMLDocument && 9 !== i; function Nt(t) { return t instanceof RegExp || t instanceof Function } function m(t) { R && R === t || (t = st(t = t && "object" === A(t) ? t : {}), a = -1 === ce.indexOf(t.PARSER_MEDIA_TYPE) ? "text/html" : t.PARSER_MEDIA_TYPE, v = "application/xhtml+xml" === a ? function (t) { return t } : G, f = "ALLOWED_TAGS" in t ? it({}, t.ALLOWED_TAGS, v) : Vt, x = "ALLOWED_ATTR" in t ? it({}, t.ALLOWED_ATTR, v) : Yt, le = "ADD_URI_SAFE_ATTR" in t ? it(st(he), t.ADD_URI_SAFE_ATTR, v) : he, ae = "ADD_DATA_URI_TAGS" in t ? it(st(oe), t.ADD_DATA_URI_TAGS, v) : oe, T = "FORBID_CONTENTS" in t ? it({}, t.FORBID_CONTENTS, v) : ne, w = "FORBID_TAGS" in t ? it({}, t.FORBID_TAGS, v) : {}, Jt = "FORBID_ATTR" in t ? it({}, t.FORBID_ATTR, v) : {}, L = "USE_PROFILES" in t && t.USE_PROFILES, Gt = !1 !== t.ALLOW_ARIA_ATTR, Zt = !1 !== t.ALLOW_DATA_ATTR, Kt = t.ALLOW_UNKNOWN_PROTOCOLS || !1, E = t.SAFE_FOR_TEMPLATES || !1, k = t.WHOLE_DOCUMENT || !1, M = t.RETURN_DOM || !1, C = t.RETURN_DOM_FRAGMENT || !1, z = t.RETURN_TRUSTED_TYPE || !1, te = t.FORCE_BODY || !1, ee = !1 !== t.SANITIZE_DOM, ie = t.SANITIZE_NAMED_PROPS || !1, re = !1 !== t.KEEP_CONTENT, S = t.IN_PLACE || !1, Xt = t.ALLOWED_URI_REGEXP || Xt, N = t.NAMESPACE || D, t.CUSTOM_ELEMENT_HANDLING && Nt(t.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (y.tagNameCheck = t.CUSTOM_ELEMENT_HANDLING.tagNameCheck), t.CUSTOM_ELEMENT_HANDLING && Nt(t.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (y.attributeNameCheck = t.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), t.CUSTOM_ELEMENT_HANDLING && "boolean" == typeof t.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (y.allowCustomizedBuiltInElements = t.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), E && (Zt = !1), C && (M = !0), L && (f = it({}, $(ut)), x = [], !0 === L.html && (it(f, ot), it(x, ct)), !0 === L.svg && (it(f, rt), it(x, pt), it(x, gt)), !0 === L.svgFilters && (it(f, ht), it(x, pt), it(x, gt)), !0 === L.mathMl && (it(f, lt), it(x, mt), it(x, gt))), t.ADD_TAGS && it(f = f === Vt ? st(f) : f, t.ADD_TAGS, v), t.ADD_ATTR && it(x = x === Yt ? st(x) : x, t.ADD_ATTR, v), t.ADD_URI_SAFE_ATTR && it(le, t.ADD_URI_SAFE_ATTR, v), t.FORBID_CONTENTS && it(T = T === ne ? st(T) : T, t.FORBID_CONTENTS, v), re && (f["#text"] = !0), k && it(f, ["html", "head", "body"]), f.table && (it(f, ["tbody"]), delete w.tbody), B && B(t), R = t) } function g(e) { Z(h.removed, { element: e }); try { e.parentNode.removeChild(e) } catch (t) { try { e.outerHTML = Et } catch (t) { e.remove() } } } function Rt(t) { te ? t = "<remove></remove>" + t : i = (i = W(t, /^[\r\n\t ]+/)) && i[0], "application/xhtml+xml" === a && (t = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + t + "</body></html>"); var e, i, s = p ? p.createHTML(t) : t; if (N === D) try { e = (new U).parseFromString(s, a) } catch (t) { } if (!e || !e.documentElement) { e = n.createDocument(N, "template", null); try { e.documentElement.innerHTML = Ft ? "" : s } catch (t) { } } return s = e.body || e.documentElement, t && i && s.insertBefore(r.createTextNode(i), s.childNodes[0] || null), N === D ? Tt.call(e, k ? "html" : "body")[0] : k ? e.documentElement : s } function It(t) { return Mt.call(t.ownerDocument || t, t, e.SHOW_ELEMENT | e.SHOW_COMMENT | e.SHOW_TEXT, null, !1) } function b(t) { return "object" === A(d) ? t instanceof d : t && "object" === A(t) && "number" == typeof t.nodeType && "string" == typeof t.nodeName } function qt(t) { if (q("beforeSanitizeElements", t, null), (n = t) instanceof j && ("string" != typeof n.nodeName || "string" != typeof n.textContent || "function" != typeof n.removeChild || !(n.attributes instanceof H) || "function" != typeof n.removeAttribute || "function" != typeof n.setAttribute || "string" != typeof n.namespaceURI || "function" != typeof n.insertBefore)) return g(t), 1; if (Q(/[\u0080-\uFFFF]/, t.nodeName)) return g(t), 1; var e, i, s, r, n = v(t.nodeName); if (q("uponSanitizeElement", t, { tagName: n, allowedTags: f }), t.hasChildNodes() && !b(t.firstElementChild) && (!b(t.content) || !b(t.content.firstElementChild)) && Q(/<[/\w]/g, t.innerHTML) && Q(/<[/\w]/g, t.textContent)) return g(t), 1; if ("select" === n && Q(/<template/i, t.innerHTML)) return g(t), 1; if (f[n] && !w[n]) return (!(t instanceof F) || ((i = c(e = t)) && i.tagName || (i = { namespaceURI: D, tagName: "template" }), s = G(e.tagName), r = G(i.tagName), e.namespaceURI === ue ? i.namespaceURI === D ? "svg" === s : i.namespaceURI === de ? "svg" === s && ("annotation-xml" === r || me[r]) : Boolean(I[s]) : e.namespaceURI === de ? i.namespaceURI === D ? "math" === s : i.namespaceURI === ue ? "math" === s && ge[r] : Boolean(ve[s]) : e.namespaceURI === D && !(i.namespaceURI === ue && !ge[r]) && !(i.namespaceURI === de && !me[r]) && !ve[s] && (be[s] || !I[s]))) && ("noscript" !== n && "noembed" !== n || !Q(/<\/no(script|embed)/i, t.innerHTML)) ? (E && 3 === t.nodeType && (e = t.textContent, e = Y(e, Ht, " "), e = Y(e, $t, " "), t.textContent !== e && (Z(h.removed, { element: t.cloneNode() }), t.textContent = e)), q("afterSanitizeElements", t, null), !1) : (g(t), !0); if (!w[n] && Pt(n)) { if (y.tagNameCheck instanceof RegExp && Q(y.tagNameCheck, n)) return; if (y.tagNameCheck instanceof Function && y.tagNameCheck(n)) return } if (re && !T[n]) { var a = c(t) || t.parentNode, o = At(t) || t.childNodes; if (o && a) for (var l = o.length - 1; 0 <= l; --l)a.insertBefore(K(o[l], !0), et(t)) } return g(t), 1 } function Pt(t) { return 0 < t.indexOf("-") } function Bt(t) { q("beforeSanitizeAttributes", t, null); var e = t.attributes; if (e) { for (var i = { attrName: "", attrValue: "", keepAttr: !0, allowedAttributes: x }, s = e.length; s--;) { o = e[s]; var r = o.name, n = o.namespaceURI, a = "value" === r ? o.value : J(o.value), o = v(r); if (i.attrName = o, i.attrValue = a, i.keepAttr = !0, i.forceKeepAttr = void 0, q("uponSanitizeAttribute", t, i), a = i.attrValue, !i.forceKeepAttr && (fe(r, t), i.keepAttr)) if (Q(/\/>/i, a)) fe(r, t); else { E && (a = Y(a, Ht, " "), a = Y(a, $t, " ")); var l = v(t.nodeName); if (xe(l, o, a)) { if (!ie || "id" !== o && "name" !== o || (fe(r, t), a = se + a), p && "object" === A(u) && "function" == typeof u.getAttributeType && !n) switch (u.getAttributeType(l, o)) { case "TrustedHTML": a = p.createHTML(a); break; case "TrustedScriptURL": a = p.createScriptURL(a) }try { n ? t.setAttributeNS(n, r, a) : t.setAttribute(r, a), X(h.removed) } catch (t) { } } } } q("afterSanitizeAttributes", t, null) } } function Ot(t) { var e, i = It(t); for (q("beforeSanitizeShadowDOM", t, null); e = i.nextNode();)q("uponSanitizeShadowNode", e, null), qt(e) || (e.content instanceof O && Ot(e.content), Bt(e)); q("afterSanitizeShadowDOM", t, null) } var a, v, Ft, Ht = bt, $t = ft, _t = xt, jt = wt, Ut = yt, Wt = kt, Xt = vt, f = null, Vt = it({}, [].concat($(ot), $(rt), $(ht), $(lt), $(ut))), x = null, Yt = it({}, [].concat($(ct), $(pt), $(mt), $(gt))), y = Object.seal(Object.create(null, { tagNameCheck: { writable: !0, configurable: !1, enumerable: !0, value: null }, attributeNameCheck: { writable: !0, configurable: !1, enumerable: !0, value: null }, allowCustomizedBuiltInElements: { writable: !0, configurable: !1, enumerable: !0, value: !1 } })), w = null, Jt = null, Gt = !0, Zt = !0, Kt = !1, E = !1, k = !1, Qt = !1, te = !1, M = !1, C = !1, z = !1, ee = !0, ie = !1, se = "user-content-", re = !0, S = !1, L = {}, T = null, ne = it({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), ae = null, oe = it({}, ["audio", "video", "img", "source", "image", "track"]), le = null, he = it({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), de = "http://www.w3.org/1998/Math/MathML", ue = "http://www.w3.org/2000/svg", D = "http://www.w3.org/1999/xhtml", N = D, ce = ["application/xhtml+xml", "text/html"], R = null, pe = r.createElement("form"), me = it({}, ["mi", "mo", "mn", "ms", "mtext"]), ge = it({}, ["foreignobject", "desc", "title", "annotation-xml"]), be = it({}, ["title", "style", "font", "a", "script"]), I = it({}, rt), ve = (it(I, ht), it(I, at), it({}, lt)), fe = (it(ve, dt), function (t, e) { try { Z(h.removed, { attribute: e.getAttributeNode(t), from: e }) } catch (t) { Z(h.removed, { attribute: null, from: e }) } if (e.removeAttribute(t), "is" === t && !x[t]) if (M || C) try { g(e) } catch (t) { } else try { e.setAttribute(t, "") } catch (t) { } }), q = function (t, e, i) { s[t] && V(s[t], function (t) { t.call(h, e, i, R) }) }, xe = function (t, e, i) { if (ee && ("id" === e || "name" === e) && (i in r || i in pe)) return !1; if ((!Zt || Jt[e] || !Q(_t, e)) && (!Gt || !Q(jt, e))) if (!x[e] || Jt[e]) { if (!(Pt(t) && (y.tagNameCheck instanceof RegExp && Q(y.tagNameCheck, t) || y.tagNameCheck instanceof Function && y.tagNameCheck(t)) && (y.attributeNameCheck instanceof RegExp && Q(y.attributeNameCheck, e) || y.attributeNameCheck instanceof Function && y.attributeNameCheck(e)) || "is" === e && y.allowCustomizedBuiltInElements && (y.tagNameCheck instanceof RegExp && Q(y.tagNameCheck, i) || y.tagNameCheck instanceof Function && y.tagNameCheck(i)))) return !1 } else if (!le[e] && !Q(Xt, Y(i, Wt, "")) && ("src" !== e && "xlink:href" !== e && "href" !== e || "script" === t || 0 !== _(i, "data:") || !ae[t]) && (!Kt || Q(Ut, Y(i, Wt, ""))) && i) return !1; return !0 }; return h.sanitize = function (t) { var e, i, s, r, n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}; if ("string" != typeof (t = (Ft = !t) ? "\x3c!--\x3e" : t) && !b(t)) { if ("function" != typeof t.toString) throw tt("toString is not a function"); if ("string" != typeof (t = t.toString())) throw tt("dirty is not a string, aborting") } if (!h.isSupported) { if ("object" === A(o.toStaticHTML) || "function" == typeof o.toStaticHTML) { if ("string" == typeof t) return o.toStaticHTML(t); if (b(t)) return o.toStaticHTML(t.outerHTML) } return t } if (Qt || m(n), h.removed = [], S = "string" == typeof t ? !1 : S) { if (t.nodeName) { var n = v(t.nodeName); if (!f[n] || w[n]) throw tt("root node is forbidden and cannot be sanitized in-place") } } else if (t instanceof d) 1 === (n = (e = Rt("\x3c!----\x3e")).ownerDocument.importNode(t, !0)).nodeType && "BODY" === n.nodeName || "HTML" === n.nodeName ? e = n : e.appendChild(n); else { if (!M && !E && !k && -1 === t.indexOf("<")) return p && z ? p.createHTML(t) : t; if (!(e = Rt(t))) return M ? null : z ? Et : "" } e && te && g(e.firstChild); for (var a = It(S ? t : e); i = a.nextNode();)3 === i.nodeType && i === s || qt(i) || (i.content instanceof O && Ot(i.content), Bt(i), s = i); if (s = null, S) return t; if (M) { if (C) for (r = Lt.call(e.ownerDocument); e.firstChild;)r.appendChild(e.firstChild); else r = e; return r = x.shadowroot ? Dt.call(l, r, !0) : r } n = k ? e.outerHTML : e.innerHTML; return k && f["!doctype"] && e.ownerDocument && e.ownerDocument.doctype && e.ownerDocument.doctype.name && Q(zt, e.ownerDocument.doctype.name) && (n = "<!DOCTYPE " + e.ownerDocument.doctype.name + ">\n" + n), E && (n = Y(n, Ht, " "), n = Y(n, $t, " ")), p && z ? p.createHTML(n) : n }, h.setConfig = function (t) { m(t), Qt = !0 }, h.clearConfig = function () { R = null, Qt = !1 }, h.isValidAttribute = function (t, e, i) { R || m({}); t = v(t), e = v(e); return xe(t, e, i) }, h.addHook = function (t, e) { "function" == typeof e && (s[t] = s[t] || [], Z(s[t], e)) }, h.removeHook = function (t) { if (s[t]) return X(s[t]) }, h.removeHooks = function (t) { s[t] && (s[t] = []) }, h.removeAllHooks = function () { s = {} }, h }(); let At = (e, i, t = !1) => { if (e.length !== i.length) return !1; if (t) { for (var s in e) if (e[s] !== i[s]) return !1 } else { for (let t = 0; t < e.length; t += 1)if (!i.includes(e[t])) return !1; for (let t = 0; t < i.length; t += 1)if (!e.includes(i[t])) return !1 } return !0 }, Lt = document.createElement("template"), Mt = (e, ...i) => { let s = []; for (let t = 0; t < e.length; t += 1)s.push(e[t]), void 0 !== i[t] && s.push(i[t]); var t = s.join(""), t = (Lt.innerHTML = t, document.importNode(Lt.content, !0)); return 1 === t.children.length ? t.firstElementChild : t }, Tt = (e, ...i) => { let s = []; for (let t = 0; t < e.length; t += 1)s.push(e[t]), void 0 !== i[t] && s.push(i[t]); let t = s.join(""), r = new CSSStyleSheet; return r.replaceSync(t), r }, $t = (e, ...i) => { let s = []; for (let t = 0; t < e.length; t += 1)s.push(e[t]), void 0 !== i[t] && s.push(i[t]); var t, r = `<svg id="x-stub" xmlns="http://www.w3.org/2000/svg">${s.join("")}</svg>`; Lt.innerHTML = r; let n = document.importNode(Lt.content, !0), a = n.querySelector("svg#x-stub"); if (1 === a.children.length) return a.firstElementChild; for (t of [...a.childNodes]) n.appendChild(t); return a.remove(), n }, Dt = {}, Rt = s => new Promise(async t => { if (Dt[s]) Dt[s].iconset ? t(Dt[s].iconset) : Dt[s].callbacks.push(t); else { Dt[s] = { callbacks: [t], iconset: null }; let e = null; try { e = await (await fetch(s)).text() } catch (t) { e = null } if (e) { Dt[s].iconset = $t`${e}`; for (var i of Dt[s].callbacks) i(Dt[s].iconset) } else console.error("Xel failed to fetch the iconset: " + s) } }); class Pt { constructor(t) { this.value = t } valueOf() { return this.value } } class It extends Pt { constructor(t = "???") { super(t) } toString(t) { return `{${this.value}}` } } class Ot extends Pt { constructor(t, e = {}) { super(t), this.opts = e } toString(e) { try { return e.memoizeIntlObject(Intl.NumberFormat, this.opts).format(this.value) } catch (t) { return e.reportError(t), this.value.toString(10) } } } class Ft extends Pt { constructor(t, e = {}) { super(t), this.opts = e } toString(e) { try { return e.memoizeIntlObject(Intl.DateTimeFormat, this.opts).format(this.value) } catch (t) { return e.reportError(t), new Date(this.value).toISOString() } } } function Bt(t, e, i) { return i === e || (i instanceof Ot && e instanceof Ot && i.value === e.value || e instanceof Ot && "string" == typeof i && i === t.memoizeIntlObject(Intl.PluralRules, e.opts).select(e.value)) } function Nt(t, e, i) { return e[i] ? qt(t, e[i].value) : (t.reportError(new RangeError("No default")), new It) } function jt(t, e) { const i = [], s = Object.create(null); for (const r of e) "narg" === r.type ? s[r.name] = Ht(t, r.value) : i.push(Ht(t, r)); return { positional: i, named: s } } function Ht(e, i) { switch (i.type) { case "str": return i.value; case "num": return new Ot(i.value, { minimumFractionDigits: i.precision }); case "var": { var [s, r] = [e, i["name"]]; let t; if (s.params) { if (!Object.prototype.hasOwnProperty.call(s.params, r)) return new It("$" + r); t = s.params[r] } else { if (!s.args || !Object.prototype.hasOwnProperty.call(s.args, r)) return s.reportError(new ReferenceError("Unknown variable: $" + r)), new It("$" + r); t = s.args[r] } if (t instanceof Pt) return t; switch (typeof t) { case "string": return t; case "number": return new Ot(t); case "object": if (t instanceof Date) return new Ft(t.getTime()); default: return s.reportError(new TypeError(`Variable type not supported: $${r}, ` + typeof t)), new It("$" + r) }return } case "mesg": return [h, { name: d, attr: o }] = [e, i], (l = h.bundle.t.get(d)) ? o ? (t = l.attributes[o]) ? qt(h, t) : (h.reportError(new ReferenceError("Unknown attribute: " + o)), new It(d + "." + o)) : l.value ? qt(h, l.value) : (h.reportError(new ReferenceError("No value: " + d)), new It(d)) : (h.reportError(new ReferenceError("Unknown message: " + d)), new It(d)); case "term": var [t, { name: n, attr: a, args: o }] = [e, i], l = "-" + n, h = t.bundle.i.get(l); if (!h) return t.reportError(new ReferenceError("Unknown term: " + l)), new It(l); if (a) { const n = h.attributes[a]; if (n) { t.params = jt(t, o).named; const a = qt(t, n); return t.params = null, a } return t.reportError(new ReferenceError("Unknown attribute: " + a)), new It(l + "." + a) } return t.params = jt(t, o).named, n = qt(t, h.value), t.params = null, n; case "func": { var [d, { name: a, args: u }] = [e, i]; let t = d.bundle.o[a]; if (!t) return d.reportError(new ReferenceError(`Unknown function: ${a}()`)), new It(a + "()"); if ("function" != typeof t) return d.reportError(new TypeError(`Function ${a}() is not callable`)), new It(a + "()"); try { var c = jt(d, u); return t(c.positional, c.named) } catch (u) { return d.reportError(u), new It(a + "()") } return } case "select": var [p, { selector: m, variants: n, star: c }] = [e, i], g = Ht(p, m); if (g instanceof It) return Nt(p, n, c); for (const m of n) if (Bt(p, g, Ht(p, m.key))) return qt(p, m.value); return Nt(p, n, c); default: return new It }var h, l } function Ut(t, e) { if (t.dirty.has(e)) return t.reportError(new RangeError("Cyclic reference")), new It; t.dirty.add(e); const i = [], s = t.bundle.h && 1 < e.length; for (const r of e) if ("string" != typeof r) { if (t.placeables++, 100 < t.placeables) throw t.dirty.delete(e), new RangeError(`Too many placeables expanded: ${t.placeables}, max allowed is 100`); s && i.push("⁨"), i.push(Ht(t, r).toString(t)), s && i.push("⁩") } else i.push(t.bundle.l(r)); return t.dirty.delete(e), i.join("") } function qt(t, e) { return "string" == typeof e ? t.bundle.l(e) : Ut(t, e) } class Kt { constructor(t, e, i) { this.dirty = new WeakSet, this.params = null, this.placeables = 0, this.bundle = t, this.errors = e, this.args = i } reportError(t) { if (!(this.errors && t instanceof Error)) throw t; this.errors.push(t) } memoizeIntlObject(t, e) { let i = this.bundle.u.get(t); i || (i = {}, this.bundle.u.set(t, i)); var s = JSON.stringify(e); return i[s] || (i[s] = new t(this.bundle.locales, e)), i[s] } } function Vt(t, e) { const i = Object.create(null); for (var [s, r] of Object.entries(t)) e.includes(s) && (i[s] = r.valueOf()); return i } const Xt = ["unitDisplay", "currencyDisplay", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits"]; function Zt(t, e) { let i = t[0]; if (i instanceof It) return new It(`NUMBER(${i.valueOf()})`); if (i instanceof Ot) return new Ot(i.valueOf(), { ...i.opts, ...Vt(e, Xt) }); if (i instanceof Ft) return new Ot(i.valueOf(), { ...Vt(e, Xt) }); throw new TypeError("Invalid argument to NUMBER") } const Gt = ["dateStyle", "timeStyle", "fractionalSecondDigits", "dayPeriod", "hour12", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName"]; function Wt(t, e) { let i = t[0]; if (i instanceof It) return new It(`DATETIME(${i.valueOf()})`); if (i instanceof Ft) return new Ft(i.valueOf(), { ...i.opts, ...Vt(e, Gt) }); if (i instanceof Ot) return new Ft(i.valueOf(), { ...Vt(e, Gt) }); throw new TypeError("Invalid argument to DATETIME") } const Yt = new Map; class _t { constructor(t, { functions: e, useIsolating: i = !0, transform: s = t => t } = {}) { this.i = new Map, this.t = new Map, this.locales = Array.isArray(t) ? t : [t], this.o = { NUMBER: Zt, DATETIME: Wt, ...e }, this.h = i, this.l = s, this.u = function (t) { t = Array.isArray(t) ? t.join(" ") : t; let e = Yt.get(t); return void 0 === e && (e = new Map, Yt.set(t, e)), e }(t) } hasMessage(t) { return this.t.has(t) } getMessage(t) { return this.t.get(t) } addResource(i, { allowOverrides: s = !1 } = {}) { const r = []; for (let e = 0; e < i.body.length; e++) { let t = i.body[e]; t.id.startsWith("-") ? !1 === s && this.i.has(t.id) ? r.push(new Error(`Attempt to override an existing term: "${t.id}"`)) : this.i.set(t.id, t) : !1 === s && this.t.has(t.id) ? r.push(new Error(`Attempt to override an existing message: "${t.id}"`)) : this.t.set(t.id, t) } return r } formatPattern(t, e = null, i = null) { if ("string" == typeof t) return this.l(t); let s = new Kt(this, i, e); try { return Ut(s, t).toString(s) } catch (t) { if (s.errors && t instanceof Error) return s.errors.push(t), (new It).toString(s); throw t } } } const Jt = /^(-?[a-zA-Z][\w-]*) *= */gm, Qt = /\.([a-zA-Z][\w-]*) *= */y, te = /\*?\[/y, ee = /(-?[0-9]+(?:\.([0-9]+))?)/y, ie = /([a-zA-Z][\w-]*)/y, se = /([$-])?([a-zA-Z][\w-]*)(?:\.([a-zA-Z][\w-]*))?/y, ne = /^[A-Z][A-Z0-9_-]*$/, oe = /([^{}\n\r]+)/y, re = /([^\\"\n\r]*)/y, he = /\\([\\"])/y, ae = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{6})/y, le = /^\n+/, de = / +$/, ue = / *\r?\n/g, ce = /( *)$/, pe = /{\s*/y, me = /\s*}/y, ge = /\[\s*/y, be = /\s*] */y, fe = /\s*\(\s*/y, xe = /\s*->\s*/y, we = /\s*:\s*/y, ve = /\s*,?\s*/y, ye = /\s+/y; class ke { constructor(o) { this.body = []; let l = Jt.lastIndex = 0; for (; ;) { var t = Jt.exec(o); if (null === t) break; l = Jt.lastIndex; try { this.body.push(function (t) { var e = u(), i = function () { let t = Object.create(null); for (; h(Qt);) { var e = d(Qt), i = u(); if (null === i) throw new SyntaxError("Expected attribute value"); t[e] = i } return t }(); if (null === e && 0 === Object.keys(i).length) throw new SyntaxError("Expected message value or attributes"); return { id: t, value: e, attributes: i } }(t[1])) } catch (o) { if (o instanceof SyntaxError) continue; throw o } } function h(t) { return t.lastIndex = l, t.test(o) } function n(t, e) { if (o[l] === t) return l++, 1; if (e) throw new e("Expected " + t) } function a(t, e) { if (h(t)) return l = t.lastIndex, 1; if (e) throw new e("Expected " + t.toString()) } function r(t) { t.lastIndex = l; var e = t.exec(o); if (null === e) throw new SyntaxError("Expected " + t.toString()); return l = t.lastIndex, e } function d(t) { return r(t)[1] } function u() { let t; if (h(oe) && (t = d(oe)), "{" === o[l] || "}" === o[l]) return i(t ? [t] : [], 1 / 0); let e = b(); return e ? t ? i([t, e], e.length) : (e.value = v(e.value, le), i([e], e.length)) : t ? v(t, de) : null } function i(t = [], e) { for (; ;)if (h(oe)) t.push(d(oe)); else if ("{" === o[l]) t.push(c()); else { if ("}" === o[l]) throw new SyntaxError("Unbalanced closing brace"); var i = b(); if (!i) break; t.push(i), e = Math.min(e, i.length) } var s, r = t.length - 1, n = t[r]; "string" == typeof n && (t[r] = v(n, de)); let a = []; for (s of t) s instanceof ze && (s = s.value.slice(0, s.value.length - e)), s && a.push(s); return a } function c() { a(pe, SyntaxError); var t, e = p(); if (a(me)) return e; if (a(xe)) return t = function () { let t, e = [], i = 0; for (; h(te);) { n("*") && (t = i); r = void 0, a(ge, SyntaxError), r = h(ee) ? g() : { type: "str", value: d(ie) }, a(be, SyntaxError); var s = u(); if (null === s) throw new SyntaxError("Expected variant value"); e[i++] = { key: r, value: s } } var r; if (0 === i) return null; if (void 0 === t) throw new SyntaxError("Expected default variant"); return { variants: e, star: t } }(), a(me, SyntaxError), { type: "select", selector: e, ...t }; throw new SyntaxError("Unclosed placeable") } function p() { if ("{" === o[l]) return c(); if (h(se)) { var [, t, e, i = null] = r(se); if ("$" === t) return { type: "var", name: e }; if (a(fe)) { var s = function () { let t = []; for (; ;) { switch (o[l]) { case ")": return l++, t; case void 0: throw new SyntaxError("Unclosed argument list") }t.push((e = void 0, "mesg" === (e = p()).type && a(we) ? { type: "narg", name: e.name, value: m() } : e)), a(ve) } var e }(); if ("-" === t) return { type: "term", name: e, attr: i, args: s }; if (ne.test(e)) return { type: "func", name: e, args: s }; throw new SyntaxError("Function names must be all upper-case") } return "-" === t ? { type: "term", name: e, attr: i, args: [] } : { type: "mesg", name: e, attr: i } } return m() } function m() { if (h(ee)) return g(); if ('"' !== o[l]) throw new SyntaxError("Invalid expression"); { n('"', SyntaxError); let t = ""; for (; ;) { if (t += d(re), "\\" !== o[l]) { if (n('"')) return { type: "str", value: t }; throw new SyntaxError("Unclosed string literal") } t += function () { if (h(he)) return d(he); { var t, e; if (h(ae)) return [, e, t] = r(ae), (e = parseInt(e || t, 16)) <= 55295 || 57344 <= e ? String.fromCodePoint(e) : "�" } throw new SyntaxError("Unknown escape sequence") }() } } } function g() { var [, t, e = ""] = r(ee), e = e.length; return { type: "num", value: parseFloat(t), precision: e } } function b() { var t = l; switch (a(ye), o[l]) { case ".": case "[": case "*": case "}": case void 0: return !1; case "{": return e(o.slice(t, l)) }return " " === o[l - 1] && e(o.slice(t, l)) } function v(t, e) { return t.replace(e, "") } function e(t) { var e = t.replace(ue, "\n"), t = ce.exec(t)[1].length; return new ze(e, t) } } } class ze { constructor(t, e) { this.value = t, this.length = e } } let Ce, Se = i => new Promise((t, e) => { setTimeout(() => t(), i) }), Ee = () => Date.now(), Ae = (s, r = 500, n) => { let a, o = null, l = null, h = 0, d = () => { h = new Date, o = null, l = s.apply(n, a) }; return (...t) => { var e = new Date, i = r - (e - h); return a = t, i <= 0 ? (clearTimeout(o), o = null, h = e, l = s.apply(n, a)) : o = o || setTimeout(d, i), l } }, Le = (i, s, r, n = !1) => { let a = null, o = null; return (...t) => { var e = n && !a; return clearTimeout(a), a = setTimeout(() => { a = null, n || (o = i.apply(r, t)) }, s), o = e ? i.apply(r, t) : o } }; var Me = new class extends class { #s = {}; addEventListener(t, e) { this.#s || (this.#s = {}); let i = this.#s[t]; i || (this.#s[t] = i = []), i.push(e), 1e4 < i.length && console.warn(`Potential EventEmitter memory leak: ${i.length} listeners subscribed to event "${t}"`) } removeEventListener(t, e) { if (this.#s && this.#s[t]) { for (var i = [], s = 0; s < this.#s[t].length; s += 1)this.#s[t][s] !== e && i.push(this.#s[t][s]); this.#s[t] = i } } dispatchEvent(r) { if (this.#s) { var n = this.#s[r.type]; if (n) { let s = null; for (let i = n.length - 1; 0 <= i; --i) { let t, e = n[i]; try { t = e.call(window, r) } catch (r) { null === s && (s = r) } if (!1 === t) break } if (s) throw s } } } }{ get theme() { return this.#n } set theme(t) { let e = document.head.querySelector(':scope > meta[name="xel-theme"]'); e || ((e = document.createElement("meta")).setAttribute("name", "xel-theme"), document.head.append(e)), e.setAttribute("content", t) } get accentColor() { return this.#o } set accentColor(t) { let e = document.head.querySelector(':scope > meta[name="xel-accent-color"]'); e || ((e = document.createElement("meta")).setAttribute("name", "xel-accent-color"), document.head.append(e)), e.setAttribute("content", t) } get size() { return this.#r } set size(t) { let e = document.head.querySelector(':scope > meta[name="xel-size"]'); e || ((e = document.createElement("meta")).setAttribute("name", "xel-size"), document.head.append(e)), e.setAttribute("content", t) } get iconsets() { return [...this.#h] } set iconsets(t) { let e = document.head.querySelector(':scope > meta[name="xel-iconsets"]'); e || ((e = document.createElement("meta")).setAttribute("name", "xel-iconsets"), document.head.append(e)), e.setAttribute("content", t.join(", ")) } get locales() { return [...this.#a] } set locales(t) { let e = document.head.querySelector(':scope > meta[name="xel-locales"]'); e || ((e = document.createElement("meta")).setAttribute("name", "xel-locales"), document.head.append(e)), e.setAttribute("content", t.join(", ")) } get locale() { return this.#l[0] || "en" } get whenThemeReady() { return new Promise(t => { null === this.#d ? t() : this.#d.push(t) }) } get whenIconsetsReady() { return new Promise(t => { null === this.#u ? t() : this.#u.push(t) }) } get whenLocalesReady() { return new Promise(t => { null === this.#c ? t() : this.#c.push(t) }) } get themeStyleSheet() { return this.#p } get presetAccentColors() { let e = {}; for (var i of this.#p.cssRules) if (1 === i.type && "body" === i.selectorText && i.styleMap.has("--preset-accent-colors")) { let t = i.styleMap.get("--preset-accent-colors"); t && t[0] && (i = t[0].split(",").map(t => t.trim()).map(t => t.split(" ")), e = Object.fromEntries(i)); break } return e } get autocapitalize() { return this.#m } queryIcon(t) { t = !1 === t.startsWith("#") ? "#" + t : t; let e = null; for (var i of this.#g) { i = i.querySelector(t); if (i) { e = i; break } } return e } queryMessage(t, e = {}) { let [i, s] = (t = t.startsWith("#") ? t.substring(1) : t).split("."), r = this.#b.getMessage(i), n = null, a = "text"; return void 0 === e.os && (e.os = Ce = void 0 === Ce ? !0 === navigator.platform.startsWith("Mac") ? "macos" : -1 !== ["iPhone", "iPad", "iPod"].indexOf(navigator.platform) ? "ios" : -1 !== ["Win32", "Win64", "Windows", "WinCE"].indexOf(navigator.platform) ? "windows" : /CrOS/.test(navigator.userAgent) ? "chromeos" : /Android/.test(navigator.userAgent) ? "android" : /Linux/.test(navigator.platform) ? "linux" : null : Ce), void 0 === s && (s = null), r && (null === s ? r.value && (n = this.#b.formatPattern(r.value, e)) : r.attributes?.[s] && (n = this.#b.formatPattern(r.attributes[s], e))), null === n ? n = null === s ? i : i + "." + s : /<|&#?\w+;/.test(n) && (a = "html", n = Et.sanitize(n, { USE_PROFILES: { html: !0 } })), { id: i, attribute: s, format: a, content: n } } #n = null; #o = null; #r = null; #h = []; #a = []; #l = []; #m = "none"; #p = new CSSStyleSheet; #g = []; #b = null; #d = []; #u = []; #c = []; constructor() { super(), document.adoptedStyleSheets = [this.#p]; var { theme: t, accentColor: e, size: i, iconsets: s, locales: r } = this.#f(); this.#n = t, this.#o = e, this.#r = i, this.#h = s, this.#a = r, this.#l = this.#a.map(t => { let e = t.substring(t.lastIndexOf("/") + 1); return e.substring(0, e.indexOf(".")) }), null !== this.#n && this.#x(this.#n), 0 < this.#h.length && this.#w(this.#h), 0 < this.#a.length && this.#v(this.#a), new MutationObserver(t => this.#y(t)).observe(document.head, { attributes: !0, subtree: !0 }) } #y(t) { var e = this.#n, i = this.#o, s = this.#r, r = this.#h, n = this.#a, { theme: a, accentColor: o, size: l, iconsets: h, locales: d } = this.#f(); this.#n = a, this.#o = o, this.#r = l, this.#h = h, this.#a = d, this.#l = this.#a.map(t => { let e = t.substring(t.lastIndexOf("/") + 1); return e.substring(0, e.indexOf(".")) }), this.#n !== e && this.#x(this.#n).then(() => { this.dispatchEvent(new CustomEvent("themechange")) }), this.#o !== i && (this.#k(), this.dispatchEvent(new CustomEvent("accentcolorchange"))), this.#r !== s && this.dispatchEvent(new CustomEvent("sizechange")), !1 === At(this.#h, r, !0) && this.#w(this.#h).then(() => { this.dispatchEvent(new CustomEvent("iconsetschange")) }), !1 === At(this.#a, n, !0) && this.#v(this.#a).then(() => { this.dispatchEvent(new CustomEvent("localeschange")) }) } #z(n) { return new Promise(async t => { let e = await fetch(n), i = await e.text(); for (var [s, r] of this.#C(i)) { s = await this.#z(s); i = i.replace(r, s) } t(i) }) } #x(s) { return new Promise(async t => { null === this.#d && (this.#d = []); var e = await this.#z(s); if (await this.#p.replace(e), this.#S(), this.#k(), this.#E(), null !== this.#d) { for (var i of this.#d) i(); this.#d = null } t() }) } #w(s) { return new Promise(async t => { null === this.#u && (this.#u = []), this.#g = []; for (var e of s) { e = await Rt(e); this.#g.push(e) } for (var i of this.#u) i(); this.#u = null, t() }) } #v(r) { return new Promise(async t => { null === this.#c && (this.#c = []); let h = r.map(t => { let e = t.substring(t.lastIndexOf("/") + 1); return e.substring(0, e.indexOf(".")) }), e = (0 === h.length && h.push("en"), new _t([h[0]], { useIsolating: !1, functions: { RELDATETIME: (n = [], t) => { let a; if (n[0] instanceof Ot) a = new Date(n[0].value); else { if ("string" != typeof n[0]) throw new TypeError("Invalid argument to RELDATETIME"); a = new Date(parseInt(n[0])) } { var [n, o = new Date, l = ["en"]] = [a, new Date, h]; let t, e = n.getTime(), i = o.getTime(), s = new Intl.RelativeTimeFormat(l, { numeric: "always" }), r = Math.round((i - e) / 1e3); return (r < 0 ? (t = 1, r = -r) : t = -1, r < 60) ? s.format(r * t, "seconds") : r < 3600 ? s.format(Math.round(r * t / 60), "minutes") : r < 86400 ? s.format(Math.round(r * t / 3600), "hours") : r < 604800 ? s.format(Math.round(r * t / 86400), "days") : r < 4233600 ? s.format(Math.round(r * t / 604800), "weeks") : (l = 12 * (n.getFullYear() - o.getFullYear()), l = (l -= o.getMonth()) + n.getMonth(), 12 < Math.abs(l) ? l < 0 ? s.format(Math.ceil(l / 12), "years") : s.format(Math.floor(l / 12), "years") : s.format(l, "months")) } } } })); for (let t = r.length - 1; 0 <= t; --t) { var i = r[t], i = await (await fetch(i)).text(), i = new ke(i), i = e.addResource(i, { allowOverrides: !0 }); i.length && console.info("Found localization syntax errors", i) } this.#b = e, this.#S(); for (var s of this.#c) s(); this.#c = null, t() }) } #S() { this.#b?.locales[0]?.startsWith("en") ? this.#m = getComputedStyle(document.body).getPropertyValue("--autocapitalize").trim() || "none" : this.#m = "none" } async#E() { await this.whenThemeReady; let t = document.head.querySelector('meta[name="theme-color"]'), e = getComputedStyle(document.body).getPropertyValue("--titlebar-color").trim() || "auto"; "auto" === e ? t && t.remove() : (null === t && ((t = document.createElement("meta")).setAttribute("name", "theme-color"), document.head.append(t)), t.setAttribute("content", e)) } async#k() { await this.whenThemeReady; let t = this.#o || this.presetAccentColors.blue, [e, i, s, r] = (this.presetAccentColors[t] && (t = this.presetAccentColors[t]), (new E).parse(t, "hsla")), n = [...this.#p.cssRules].reverse().find(t => 1 === t.type && "body" === t.selectorText); n.styleMap.set("--accent-color-h", e), n.styleMap.set("--accent-color-s", i + "%"), n.styleMap.set("--accent-color-l", s + "%"), n.styleMap.set("--accent-color-a", r) } #f() { let t = document.head.querySelector(':scope > meta[name="xel-theme"]'), e = document.head.querySelector(':scope > meta[name="xel-accent-color"]'), i = document.head.querySelector(':scope > meta[name="xel-size"]'), s = document.head.querySelector(':scope > meta[name="xel-iconsets"]'), r = document.head.querySelector(':scope > meta[name="xel-locales"]'); return { theme: t && "" !== t.content ? t.content : null, accentColor: e && "" !== e.content ? e.content : null, size: i && "" !== i.content ? i.content : null, iconsets: s ? s.content.split(",").map(t => t.trim()).filter(t => "" !== t) : [], locales: r ? r.content.split(",").map(t => t.trim()).filter(t => "" !== t) : [] } } #C(n) { let a = [], o = -1; for (; ;) { var l = n.indexOf("@import", o); if (!(-1 < l)) break; { let t = n.indexOf(";", l), e = 0, i = n.indexOf(".css", l) + ".css".length, s = n.indexOf("'", l), r = n.indexOf('"', l); l < s && s < t ? e = s + 1 : l < r && r < t ? e = r + 1 : l < (h = n.indexOf("url(", l)) && h < t && (e = h + "url(".length); var h = n.substring(e, i); a.push([h, n.substring(l, t + 1)]), o = i } } return a } }; if (!1 === MouseEvent.prototype.hasOwnProperty("pointerType") && Object.defineProperty(MouseEvent.prototype, "pointerType", { get() { return this.sourceCapabilities.firesTouchEvents ? "touch" : "mouse" } }), Element.prototype.setPointerCapture) { let r = Element.prototype.setPointerCapture; Element.prototype.setPointerCapture = function (t) { r.call(this, t); let i = getComputedStyle(this).cursor, s = []; for (let e = this.parentNode || this.host; e && e !== document; e = e.parentNode || e.host)if (e.nodeType === document.DOCUMENT_FRAGMENT_NODE) { let t = document.createElementNS(e.host.namespaceURI, "style"); t.textContent = `* { cursor: ${i} !important; user-select: none !important; }`, e.append(t), s.push(t) } else if (e.nodeType === document.DOCUMENT_NODE) { let t = document.createElement("style"); t.textContent = `* { cursor: ${i} !important; user-select: none !important; }`, e.head.append(t), s.push(t) } let e = () => { window.removeEventListener("pointerup", e, !0), this.removeEventListener("lostpointercapture", e); for (var t of s) t.remove() }; window.addEventListener("pointerup", e, !0), this.addEventListener("lostpointercapture", e) } } Object.defineProperty(Animation.prototype, "finished", { get() { return new Promise(t => { "finished" === this.playState ? t() : this.addEventListener("finish", () => t(), { once: !0 }) }) } }), Object.defineProperty(HTMLHeadingElement.prototype, "disabled", { enumerable: !1, configurable: !1, get() { return this.hasAttribute("disabled") }, set(t) { !0 === t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled") } }), Object.defineProperty(HTMLParagraphElement.prototype, "disabled", { enumerable: !1, configurable: !1, get() { return this.hasAttribute("disabled") }, set(t) { !0 === t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled") } }), Node.prototype.append || (Node.prototype.append = function (t) { this.appendChild(t) }), Node.prototype.prepend || (Node.prototype.prepend = function (t) { this.insertBefore(t, this.firstElementChild) }), Node.prototype.before || (Node.prototype.before = function (t) { this.parentElement.insertBefore(t, this) }), Node.prototype.after || (Node.prototype.after = function (t) { this.parentElement.insertBefore(t, this.nextElementSibling) }), Node.prototype.closest || (Node.prototype.closest = function (t) { return this.parentNode ? this.parentNode.closest(t) : null }), Node.prototype.replaceWith || (Node.prototype.replaceWith = function (t) { this.parentNode.replaceChild(t, this) }); let Te = HTMLDialogElement.prototype.showModal, $e = HTMLDialogElement.prototype.close, De = [], Re = { get open() { return this.hasAttribute("open") }, showModal() { return new Promise(async t => { if (!0 !== this.open && !1 !== this.isConnected) { this.p && await this.p.finished, this.m && await this.m.finished, Te.apply(this, arguments); { let e; document.body.style.overflow = "hidden", De.push(this), this.addEventListener("close", e = t => { t.target === this && (this.removeEventListener("close", e), 0 === (De = De.filter(t => t !== this)).length && (document.body.style.overflow = null)) }) } { let t = this.querySelector("[autofocus]"); (t || this).focus() } if (!1 === this.hasAttribute("hidden")) { let t = getComputedStyle(this), e = t.getPropertyValue("transition-property"), i = 1e3 * parseFloat(t.getPropertyValue("transition-duration")), s = t.getPropertyValue("transition-timing-function"), r = this.getBoundingClientRect(); "transform" === e && ("0px" === getComputedStyle(this).left && "0px" !== getComputedStyle(this).right ? this.p = this.animate({ transform: [`translateX(-${r.right}px)`, "translateX(0px)"] }, { duration: i, easing: s }) : "0px" === getComputedStyle(this).right && "0px" !== getComputedStyle(this).left ? this.p = this.animate({ transform: [`translateX(${r.width}px)`, "translateX(0px)"] }, { duration: i, easing: s }) : "0px" === getComputedStyle(this).marginTop && "0px" === getComputedStyle(this).marginBottom ? this.p = this.animate({ transform: [`translateY(-${r.bottom}px)`, "translateY(0px)"] }, { duration: i, easing: s }) : this.p = this.animate({ transform: ["scaleY(0)", "scaleY(1)"] }, { duration: i, easing: s })) } { let e, i, s; this.addEventListener("keydown", e = t => { "Escape" === t.key && t.preventDefault() }), document.addEventListener("keydown", i = t => { "Escape" === t.key && t.target === document.body && t.preventDefault() }), this.addEventListener("close", s = t => { t.target === this && (this.removeEventListener("close", s), this.removeEventListener("keydown", e), document.removeEventListener("keydown", i)) }) } { let e, i, s, r = !0, n = t => { var e = this.getBoundingClientRect(); return t.clientX >= e.x && t.clientX <= e.x + e.width && t.clientY >= e.y && t.clientY <= e.y + e.height }; this.addEventListener("pointerdown", e = t => { r = !1 === n(t) }), this.addEventListener("click", i = t => { t.target === this && !0 === t.isTrusted && !1 === t.defaultPrevented && !0 === r && !1 === n(t) && !0 === this.hasAttribute("open") && (this.close(), this.dispatchEvent(new CustomEvent("userclose"))) }), this.addEventListener("close", s = t => { t.target === this && (this.removeEventListener("pointerdown", e), this.removeEventListener("click", i), this.removeEventListener("close", s)) }) } this.p && (await this.p.finished, this.p = null), t() } else t() }) }, close() { return new Promise(async t => { if (this.p && await this.p.finished, this.m && await this.m.finished, !1 === this.hasAttribute("hidden")) { let t = getComputedStyle(this), e = t.getPropertyValue("transition-property"), i = t.getPropertyValue("transition-duration") || "0s", s = 1e3 * parseFloat(i), r = t.getPropertyValue("transition-timing-function") || "ease", n = this.getBoundingClientRect(); "transform" === e && ("0px" === getComputedStyle(this).left && "0px" !== getComputedStyle(this).right ? this.m = this.animate({ transform: ["translateX(0px)", `translateX(-${n.right}px)`] }, { duration: s, easing: r }) : "0px" === getComputedStyle(this).right && "0px" !== getComputedStyle(this).left ? this.m = this.animate({ transform: ["translateX(0px)", `translateX(${n.width}px)`] }, { duration: s, easing: r }) : "0px" === getComputedStyle(this).marginTop && "0px" === getComputedStyle(this).marginBottom ? this.m = this.animate({ transform: ["translateY(0px)", `translateY(-${n.bottom + 50}px)`] }, { duration: s, easing: r }) : this.m = this.animate({ transform: ["scaleY(1)", "scaleY(0)"] }, { duration: s, easing: r })) } this.m && (await this.m.finished, this.m = null), this.hasAttribute("open") && $e.apply(this, arguments), t() }) } }; for (let [t, e] of Object.entries(Object.getOwnPropertyDescriptors(Re))) Object.defineProperty(HTMLDialogElement.prototype, t, e); class Pe extends HTMLElement { static observedAttributes = ["expanded", "size"]; static #A = Mt`<template><main id="main"><div id="arrow-container"><svg id="arrow" part="arrow" viewBox="0 0 100 100" preserveAspectRatio="none" tabindex="1"><path></path></svg></div><slot></slot></main></template>`; static #L = Tt`:host{display:block;width:100%;margin:8px 0;box-sizing:border-box}:host([animating]){overflow:hidden}#main{position:relative;width:100%;height:100%}#arrow-container{position:absolute;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:flex-start;pointer-events:none}#arrow{display:flex;width:16px;height:16px;d:path("M 26 20 L 26 80 L 74 50 Z");transform:rotate(0);transition:transform .25s cubic-bezier(.4, 0, .2, 1);color:currentColor}#arrow:focus{background:0 0;outline:0}:host([expanded]) #arrow{transform:rotate(90deg)}#arrow path{fill:currentColor;d:inherit}`; get expanded() { return this.hasAttribute("expanded") } set expanded(t) { t ? this.setAttribute("expanded", "") : this.removeAttribute("expanded") } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } #M = {}; #T = null; #$ = null; #D = null; #R = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [Pe.#L], this.#T.append(document.importNode(Pe.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t; this.#$ = new ResizeObserver(() => this.#P()), this.addEventListener("click", t => this.#I(t)), this.#M.arrow.addEventListener("keydown", t => this.#O(t)) } connectedCallback() { this.#F(), Me.addEventListener("sizechange", this.#D = () => this.#F()), this.#$.observe(this) } disconnectedCallback() { Me.removeEventListener("sizechange", this.#D), this.#$.unobserve(this) } attributeChangedCallback(t, e, i) { e !== i && ("expanded" === t ? this.#P() : "size" === t && this.#F()) } expand() { return new Promise(async t => { var e, i; !1 === this.expanded && (i = this.getBoundingClientRect(), this.#R && this.#R.finish(), this.expanded = !0, this.removeAttribute("animating"), e = this.getBoundingClientRect(), this.setAttribute("animating", ""), i = this.animate({ height: [i.height + "px", e.height + "px"] }, { duration: 300, easing: "cubic-bezier(0.4, 0, 0.2, 1)" }), await (this.#R = i).finished, this.#R === i && this.removeAttribute("animating")), t() }) } collapse() { return new Promise(async t => { var e, i; !0 === this.expanded && (i = this.getBoundingClientRect(), this.#R && this.#R.finish(), this.expanded = !1, this.removeAttribute("animating"), e = this.getBoundingClientRect(), this.setAttribute("animating", ""), i = this.animate({ height: [i.height + "px", e.height + "px"] }, { duration: 300, easing: "cubic-bezier(0.4, 0, 0.2, 1)" }), await (this.#R = i).finished, this.#R === i && this.removeAttribute("animating")), t() }) } #P() { let t = this.querySelector(":scope > header"); this.#M["arrow-container"].style.height = t ? t.getBoundingClientRect().height + "px" : null } #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } #O(t) { "Enter" === t.key && this.querySelector("header").click() } #I(t) { let e = this.querySelector("header"), i = t.target.closest("[tabindex]"); e.contains(t.target) && !1 === this.contains(i) && (this.expanded ? (this.collapse(), this.dispatchEvent(new CustomEvent("collapse"))) : (this.expand(), this.dispatchEvent(new CustomEvent("expand")))) } } customElements.define("x-accordion", Pe); class Ie extends HTMLElement { static #L = Tt`:host{display:block;position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:1000;touch-action:none;will-change:opacity;cursor:default;background:rgba(0,0,0,.5)}:host([hidden]){display:none}`; get ownerElement() { return this.#B || document.body.firstElementChild } set ownerElement(t) { this.#B = t } #T = null; #B = null; #N = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [Ie.#L], this.addEventListener("pointerdown", t => t.preventDefault()) } connectedCallback() { this.addEventListener("wheel", this.#N = t => t.preventDefault()) } disconnectedCallback() { this.removeEventListener("wheel", this.#N) } show(t = !0) { this.title = "", this.style.top = "0px", this.style.left = "0px", this.ownerElement.before(this), this.hidden = !1; let e = this.getBoundingClientRect(), i = 0, s = 0; 0 === e.top && 0 === e.left || (i = -e.top, s = -e.left); var r = parseFloat(getComputedStyle(this.ownerElement).zIndex); if (this.style.zIndex = r - 1, this.style.top = i + "px", this.style.left = s + "px", t) return this.animate({ opacity: ["0", "1"] }, { duration: 100, easing: "ease-out" }).finished } hide(t = !0) { if (t) { let t = this.animate({ opacity: ["1", "0"] }, { duration: 100, easing: "ease-in" }); return t.finished.then(() => { this.remove() }), t.finished } this.remove() } } customElements.define("x-backdrop", Ie); class Oe extends HTMLElement {
    static observedAttributes = ["value", "size"]; static #A = Mt`<template><x-box vertical><div id="hue-slider" part="slider"><div id="hue-slider-track"><div id="hue-slider-marker" part="marker"></div></div></div><div id="saturation-slider" part="slider"><div id="saturation-slider-track"><div id="saturation-slider-marker" part="marker"></div></div></div><div id="lightness-slider" part="slider"><div id="lightness-slider-track"><div id="lightness-slider-marker" part="marker"></div></div></div><div id="alpha-slider" part="slider"><div id="alpha-slider-gradient"></div><div id="alpha-slider-track"><div id="alpha-slider-marker" part="marker"></div></div></div></x-box></template>`; static #L = Tt`:host{display:block;width:100%;user-select:none}:host([hidden]){display:none}#hue-slider{width:100%;height:30px;padding:0 calc(var(--marker-width)/ 2);box-sizing:border-box;border-radius:2px;touch-action:pan-y;background:red;--marker-width:18px}:host([computedsize=small]) #hue-slider{height:24px}:host([computedsize=large]) #hue-slider{height:35px}#hue-slider-track{width:100%;height:100%;position:relative;display:flex;align-items:center;background:linear-gradient(to right,red,#ff0,#0f0,#0ff,#00f,#f0f,red)}#hue-slider-marker{position:absolute;left:0;background:rgba(0,0,0,.2);box-shadow:0 0 3px #000;box-sizing:border-box;transform:translateX(calc((var(--marker-width)/ 2) * -1));border:3px solid #fff;width:var(--marker-width);height:calc(100% + 6px);position:absolute}#saturation-slider{width:100%;height:30px;margin-top:20px;padding:0 calc(var(--marker-width)/ 2);box-sizing:border-box;border-radius:2px;touch-action:pan-y;--marker-width:18px}:host([computedsize=small]) #saturation-slider{height:24px}:host([computedsize=large]) #saturation-slider{height:35px}#saturation-slider-track{width:100%;height:100%;position:relative;display:flex;align-items:center}#saturation-slider-marker{position:absolute;left:0;background:rgba(0,0,0,.2);box-shadow:0 0 3px #000;box-sizing:border-box;transform:translateX(calc((var(--marker-width)/ 2) * -1));border:3px solid #fff;width:var(--marker-width);height:calc(100% + 6px);position:absolute}#lightness-slider{width:100%;height:30px;margin-top:20px;padding:0 calc(var(--marker-width)/ 2);box-sizing:border-box;border-radius:2px;touch-action:pan-y;--marker-width:18px}:host([computedsize=small]) #lightness-slider{height:24px}:host([computedsize=large]) #lightness-slider{height:35px}#lightness-slider-track{width:100%;height:100%;position:relative;display:flex;align-items:center}#lightness-slider-marker{position:absolute;left:0;background:rgba(0,0,0,.2);box-shadow:0 0 3px #000;box-sizing:border-box;transform:translateX(calc((var(--marker-width)/ 2) * -1));border:3px solid #fff;width:var(--marker-width);height:calc(100% + 6px);position:absolute}#alpha-slider{display:none;width:100%;height:30px;margin-top:20px;margin-bottom:8px;padding:0 calc(var(--marker-width)/ 2);position:relative;box-sizing:border-box;border-radius:2px;touch-action:pan-y;--marker-width:18px;background-size:10px 10px;background-position:0 0,0 5px,5px -5px,-5px 0;background-image:linear-gradient(45deg,#d6d6d6 25%,transparent 25%),linear-gradient(-45deg,#d6d6d6 25%,transparent 25%),linear-gradient(45deg,transparent 75%,#d6d6d6 75%),linear-gradient(-45deg,transparent 75%,#d6d6d6 75%)}:host([alphaslider]) #alpha-slider{display:block}:host([computedsize=small]) #alpha-slider{height:24px}:host([computedsize=large]) #alpha-slider{height:35px}#alpha-slider-gradient{position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit}#alpha-slider-track{width:100%;height:100%;position:relative;display:flex;align-items:center}#alpha-slider-marker{position:absolute;left:0;background:rgba(0,0,0,.2);box-shadow:0 0 3px #000;box-sizing:border-box;transform:translateX(calc((var(--marker-width)/ 2) * -1));border:3px solid #fff;width:var(--marker-width);height:calc(100% + 6px);position:absolute}`; get value() { return this.hasAttribute("value") ? this.getAttribute("value") : "hsla(0, 0%, 100%, 1)" } set value(t) { this.setAttribute("value", t) } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } #j = 0; #H = 0; #U = 80; #q = 1; #T = null; #M = {}; #D = null; #K = !1; #V = !1; #X = !1; #Z = !1; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [Oe.#L], this.#T.append(document.importNode(Oe.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t; this.#M["hue-slider"].addEventListener("pointerdown", t => { this.#G(t) }), this.#M["saturation-slider"].addEventListener("pointerdown", t => { this.#W(t) }), this.#M["lightness-slider"].addEventListener("pointerdown", t => { this.#Y(t) }), this.#M["alpha-slider"].addEventListener("pointerdown", t => { this.#_(t) }) } connectedCallback() { this.#J(), this.#F(), Me.addEventListener("sizechange", this.#D = () => this.#F()) } disconnectedCallback() { Me.removeEventListener("sizechange", this.#D) } attributeChangedCallback(t, e, i) { e !== i && ("value" === t ? this.#Q() : "size" === t && this.#tt()) } #J() { this.#et(), this.#it(), this.#st(), this.#nt(), this.#ot(), this.#rt(), this.#ht() } #et() { this.#M["hue-slider-marker"].style.left = h(this.#j, 0, 360, 0) / 360 * 100 + "%" } #it() { this.#M["saturation-slider-marker"].style.left = h(this.#H, 0, 100, 2) + "%" } #nt() { this.#M["lightness-slider-marker"].style.left = h(this.#U, 0, 100, 2) + "%" } #rt() { this.#M["alpha-slider-marker"].style.left = h(100 * (1 - this.#q), 0, 100, 2) + "%" } #st() {
        var t = this.#j; this.#M["saturation-slider"].style.background = `linear-gradient(
      to right, hsl(${t}, 0%, 50%), hsl(${t}, 100%, 50%)
    )`} #ot() {
        var t = this.#j, e = this.#H; this.#M["lightness-slider"].style.background = `linear-gradient(
      to right, hsl(${t}, ${e}%, 0%), hsl(${t}, ${e}%, 50%), hsl(${t}, ${e}%, 100%)
    )`} #ht() {
        var t = this.#j, e = this.#H, i = this.#U; this.#M["alpha-slider-gradient"].style.background = `
      linear-gradient(to right, hsla(${t}, ${e}%, ${i}%, 1), hsla(${t}, ${e}%, ${i}%, 0))
    `} #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } #Q() { var t, e, i, s; !1 === this.#K && !1 === this.#V && !1 === this.#X && !1 === this.#Z && ([t, e, i, s] = (new E).parse(this.value, "hsla"), this.#j = t, this.#H = e, this.#U = i, this.#q = s, this.#J()) } #tt() { this.#F() } #G(r) { if (!(1 < r.buttons)) { let t, e, i = this.#M["hue-slider-track"].getBoundingClientRect(), s = (this.#K = !0, this.#M["hue-slider"].setPointerCapture(r.pointerId), this.dispatchEvent(new CustomEvent("changestart", { bubbles: !0 })), t => { t = (t - i.x) / i.width * 360; (t = h(t, 0, 360, 0)) !== this.#j && (this.#j = t, this.value = v([this.#j, this.#H, this.#U, this.#q], "hsla", "hsla"), this.#et(), this.#st(), this.#ot(), this.#ht(), this.dispatchEvent(new CustomEvent("change", { bubbles: !0 }))) }); s(r.clientX), this.#M["hue-slider"].addEventListener("pointermove", t = t => { s(t.clientX) }), this.#M["hue-slider"].addEventListener("pointerup", e = () => { this.#M["hue-slider"].removeEventListener("pointermove", t), this.#M["hue-slider"].removeEventListener("pointerup", e), this.dispatchEvent(new CustomEvent("changeend", { bubbles: !0 })), this.#K = !1 }) } } #W(r) { if (!(1 < r.buttons)) { let t, e, i = this.#M["saturation-slider-track"].getBoundingClientRect(), s = (this.#V = !0, this.#M["saturation-slider"].setPointerCapture(r.pointerId), this.dispatchEvent(new CustomEvent("changestart", { bubbles: !0 })), t => { t = (t - i.x) / i.width * 100; (t = h(t, 0, 100, 0)) !== this.#H && (this.#H = t, this.value = v([this.#j, this.#H, this.#U, this.#q], "hsla", "hsla"), this.#it(), this.#st(), this.#ot(), this.#ht(), this.dispatchEvent(new CustomEvent("change", { bubbles: !0 }))) }); s(r.clientX), this.#M["saturation-slider"].addEventListener("pointermove", t = t => { s(t.clientX) }), this.#M["saturation-slider"].addEventListener("pointerup", e = () => { this.#M["saturation-slider"].removeEventListener("pointermove", t), this.#M["saturation-slider"].removeEventListener("pointerup", e), this.dispatchEvent(new CustomEvent("changeend", { bubbles: !0 })), this.#V = !1 }) } } #Y(r) { if (!(1 < r.buttons)) { let t, e, i = this.#M["lightness-slider-track"].getBoundingClientRect(), s = (this.#X = !0, this.#M["lightness-slider"].setPointerCapture(r.pointerId), this.dispatchEvent(new CustomEvent("changestart", { bubbles: !0 })), t => { t = (t - i.x) / i.width * 100; (t = h(t, 0, 100, 0)) !== this.#U && (this.#U = t, this.value = v([this.#j, this.#H, this.#U, this.#q], "hsla", "hsla"), this.#nt(), this.#st(), this.#ot(), this.#ht(), this.dispatchEvent(new CustomEvent("change", { bubbles: !0 }))) }); s(r.clientX), this.#M["lightness-slider"].addEventListener("pointermove", t = t => { s(t.clientX) }), this.#M["lightness-slider"].addEventListener("pointerup", e = () => { this.#M["lightness-slider"].removeEventListener("pointermove", t), this.#M["lightness-slider"].removeEventListener("pointerup", e), this.dispatchEvent(new CustomEvent("changeend", { bubbles: !0 })), this.#X = !1 }) } } #_(r) { if (!(1 < r.buttons)) { let t, e, i = this.#M["alpha-slider-track"].getBoundingClientRect(), s = (this.#Z = !0, this.#M["alpha-slider"].setPointerCapture(r.pointerId), this.dispatchEvent(new CustomEvent("changestart", { bubbles: !0 })), t => { t = 1 - (t - i.x) / i.width; (t = h(t, 0, 1, 2)) !== this.#q && (this.#q = t, this.value = v([this.#j, this.#H, this.#U, this.#q], "hsla", "hsla"), this.#rt(), this.dispatchEvent(new CustomEvent("change", { bubbles: !0 }))) }); s(r.clientX), this.#M["alpha-slider"].addEventListener("pointermove", t = t => { s(t.clientX) }), this.#M["alpha-slider"].addEventListener("pointerup", e = () => { this.#M["alpha-slider"].removeEventListener("pointermove", t), this.#M["alpha-slider"].removeEventListener("pointerup", e), this.dispatchEvent(new CustomEvent("changeend", { bubbles: !0 })), this.#Z = !1 }) } }
} customElements.define("x-barscolorpicker", Oe); class Fe extends HTMLElement { static #A = Mt`<template><slot></slot></template>`; static #L = Tt`:host{display:flex;box-sizing:border-box;align-items:center;justify-content:flex-start}:host([vertical]){flex-flow:column;align-items:flex-start;justify-content:center}:host([hidden]){display:none}`; get vertical() { return this.hasAttribute("vertical") } set vertical(t) { t ? this.setAttribute("vertical", "") : this.removeAttribute("vertical") } #T = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [Fe.#L], this.#T.append(document.importNode(Fe.#A.content, !0)) } } customElements.define("x-box", Fe); let Be = (t, e = null) => { let i = t.split(":"), s = null; return 1 === i.length ? ([t] = i, s = null === e ? document.createElement(t) : document.createElement(t, e)) : 2 === i.length && ([t, e] = i, "svg" === t && (s = document.createElementNS("http://www.w3.org/2000/svg", e))), s }, Ne = (t, e, i = !0) => { var s = t.closest(e); return i && !s && t.getRootNode().host ? Ne(t.getRootNode().host, e) : s }, je = t => { let i = e => e && e !== document.body ? (() => { let t = getComputedStyle(e, null); return /(auto|scroll)/.test(t.getPropertyValue("overflow") + t.getPropertyValue("overflow-y") + t.getPropertyValue("overflow-x")) })() && "x-texteditor" !== e.localName ? e : i(e.parentElement || e.parentNode.host) : document.body; return i(t) }, He = Math["max"]; class Ue extends HTMLElement { static observedAttributes = ["disabled", "size", "skin"]; static #A = Mt`<template><div id="ripples"></div><slot></slot><svg id="arrow" part="arrow" viewBox="0 0 100 100" preserveAspectRatio="none"><path id="arrow-path"></path></svg></template>`; static #L = Tt`:host{display:flex;align-items:center;justify-content:center;width:fit-content;height:fit-content;min-height:32px;padding:2px 14px;box-sizing:border-box;opacity:1;position:relative;--trigger-effect:none}:host(:focus){outline:0}:host(:focus:not(:active)){z-index:1}:host([mixed]){opacity:.75}:host([disabled]){pointer-events:none;opacity:.5}:host([hidden]){display:none}#arrow{color:currentColor;width:8px;height:8px;min-width:8px;margin:0 0 0 4px;d:path("M 11.7 19.9 L 49.8 57.9 L 87.9 19.9 L 99.7 31.6 L 49.8 81.4 L -0.0 31.6 Z")}#arrow path{fill:currentColor;d:inherit}#arrow[hidden]{display:none}#ripples{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;border-radius:inherit}#ripples .ripple{position:absolute;top:0;left:0;width:200px;height:200px;background:currentColor;opacity:.2;border-radius:999px;transform:none;transition:all .8s cubic-bezier(.4, 0, .2, 1);will-change:opacity,transform;pointer-events:none}`; get value() { return this.hasAttribute("value") ? this.getAttribute("value") : null } set value(t) { null === t ? this.removeAttribute("value") : this.setAttribute("value", t) } get toggled() { return this.hasAttribute("toggled") } set toggled(t) { t ? this.setAttribute("toggled", "") : this.removeAttribute("toggled") } get togglable() { return this.hasAttribute("togglable") } set togglable(t) { t ? this.setAttribute("togglable", "") : this.removeAttribute("togglable") } get mixed() { return this.hasAttribute("mixed") } set mixed(t) { t ? this.setAttribute("mixed", "") : this.removeAttribute("mixed") } get disabled() { return this.hasAttribute("disabled") } set disabled(t) { t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled") } get condensed() { return this.hasAttribute("condensed") } set condensed(t) { t ? this.setAttribute("condensed", "") : this.removeAttribute("condensed") } get skin() { return this.hasAttribute("skin") ? this.getAttribute("skin") : null } set skin(t) { null === t ? this.removeAttribute("skin") : this.setAttribute("skin", t) } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } get expanded() { return this.hasAttribute("expanded") } get expandable() { return this.#at() || this.#lt() } get ownerButtons() { if (this.parentElement) { if ("x-buttons" === this.parentElement.localName) return this.parentElement; if ("x-box" === this.parentElement.localName && this.parentElement.parentElement && "x-buttons" === this.parentElement.parentElement.localName) return this.parentElement.parentElement } return null } #T = null; #M = {}; #dt = !1; #ut = null; #ct = 0; #D = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [Ue.#L], this.#T.append(document.importNode(Ue.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t; this.addEventListener("pointerdown", t => this.#pt(t)), this.addEventListener("pointerenter", () => this.#mt()), this.addEventListener("pointerleave", () => this.#gt()), this.addEventListener("click", t => this.#I(t)), this.addEventListener("keydown", t => this.#bt(t)), (async () => { await customElements.whenDefined("x-backdrop"), this.#M.backdrop = Be("x-backdrop"), this.#M.backdrop.style.background = "rgba(0, 0, 0, 0)" })() } connectedCallback() { this.parentElement && "a" === this.parentElement.localName && -1 !== this.parentElement.tabIndex && (this.parentElement.tabIndex = -1), this.#ft(), this.#xt(), this.#wt(), this.#F(), Me.addEventListener("sizechange", this.#D = () => this.#F()) } disconnectedCallback() { Me.removeEventListener("sizechange", this.#D) } attributeChangedCallback(t) { "disabled" === t ? this.#xt() : "skin" === t ? this.#wt() : "size" === t && this.#F() } expand() { return new Promise(async t => { this.#at() ? await this.#vt() : this.#lt() && await this.#yt(), t() }) } collapse(e = null) { return new Promise(async t => { this.#kt() ? await this.#zt(e) : this.#Ct() && await this.#St(e), t() }) } #vt() { return new Promise(async t => { if (this.#at()) { let t = this.querySelector(":scope > x-menu"), e = this.querySelector(":scope > x-tooltip"); e && e.close(!1), this.#dt = this.matches(":focus"), this.setAttribute("expanded", ""), this.#M.backdrop.ownerElement = t, this.#M.backdrop.show(!1), await t.openNextToElement(this, "vertical", 3), t.focus() } t() }) } #zt(e = null) { return new Promise(async t => { if (this.#kt()) { let t = this.querySelector(":scope > x-menu"); if (t.setAttribute("closing", ""), await e, await t.close(), this.#M.backdrop.hide(!1), this.removeAttribute("expanded"), this.replaceWith(this), this.#dt) this.focus(); else { let t = Ne(this.parentNode, "[tabindex]"); t && t.focus() } t.removeAttribute("closing") } t() }) } #at() { let e = !1; if (!1 === this.disabled) { let t = this.querySelector(":scope > x-menu"); t && !1 === t.hasAttribute("opened") && !1 === t.hasAttribute("closing") && null !== t.querySelector("x-menuitem") && (e = !0) } return e } #kt() { let t = !1; var e; return t = !1 === this.disabled && (e = this.querySelector(":scope > x-menu")) && e.opened ? !0 : t } #yt() { return new Promise(async t => { if (this.#lt()) { let t = this.querySelector(":scope > x-popover"), e = this.querySelector(":scope > x-tooltip"); e && e.close(!1), this.#dt = this.matches(":focus"), this.setAttribute("expanded", ""), await t.open(this) } t() }) } #St(e = null) { return new Promise(async t => { if (this.#Ct()) { let t = this.querySelector(":scope > x-popover"); if (t.setAttribute("closing", ""), await e, await t.close(), this.removeAttribute("expanded"), t.modal && this.replaceWith(this), this.#dt) this.focus(); else { let t = Ne(this.parentNode, "[tabindex]"); t && t.focus() } t.removeAttribute("closing") } t() }) } #lt() { let e = !1; if (!1 === this.disabled) { let t = this.querySelector(":scope > x-popover"); t && !1 === t.hasAttribute("opened") && (e = !0) } return e } #Ct() { let t = !1; var e; return t = !1 === this.disabled && (e = this.querySelector(":scope > x-popover")) && e.opened ? !0 : t } #Et() { return new Promise(t => { this.#At() && this.querySelector(":scope > dialog").showModal(), t() }) } #At() { let e = !1; if (!1 === this.disabled) { let t = this.querySelector(":scope > dialog"); t && !1 === t.hasAttribute("open") && !1 === t.hasAttribute("closing") && (e = !0) } return e } #Lt() { return new Promise(t => { this.#Mt() && (this.querySelector(":scope > x-notification").opened = !0), t() }) } #Mt() { let e = !1; if (!1 === this.disabled) { let t = this.querySelector(":scope > x-notification"); !t || t.hasAttribute("opened") || t.hasAttribute("closing") || (e = !0) } return e } #ft() { var t = this.querySelector(":scope > x-menu, :scope > x-popover"); this.#M.arrow.style.display = t ? null : "none" } #xt() { this.setAttribute("role", "button"), this.setAttribute("aria-disabled", this.disabled), this.disabled ? (this.#ct = 0 < this.tabIndex ? this.tabIndex : 0, this.tabIndex = -1) : (this.tabIndex < 0 && (this.tabIndex = 0 < this.#ct ? this.#ct : 0), this.#ct = 0) } #wt() { !1 === this.hasAttribute("skin") && this.setAttribute("skin", "default") } #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } #pt(t) { let e = this.querySelector(":scope > x-menu[opened]"), i = this.querySelector(":scope > x-popover[opened]"), s = this.querySelector(":scope > dialog[open]"), r = this.querySelector(":scope > x-notification[opened]"); (this.#ut = t).target === this.#M.backdrop ? this.#Tt(t) : e && e.contains(t.target) || i && i.contains(t.target) || s && s.contains(t.target) || r && r.contains(t.target) || this.#$t(t) } #mt() { let t = this.querySelector(":scope > x-tooltip"); if (t && !1 === t.disabled) { if (this.parentElement && "x-buttons" === this.parentElement.localName) for (var e of this.parentElement.children) if (e !== this && "x-button" === e.localName) { let t = e.querySelector(":scope > x-tooltip"); t && t.close(!1) } t.open(this) } } #gt() { let t = this.querySelector(":scope > x-tooltip"); t && t.close() } #I(t) { let e = this.querySelector(":scope > x-menu[opened]"), i = this.querySelector(":scope > x-popover[opened]"), s = this.querySelector(":scope > dialog[open]"), r = this.querySelector(":scope > x-notification[opened]"); t.target !== this.#M.backdrop && (e && e.contains(t.target) ? !1 === e.hasAttribute("closing") && t.target.closest("x-menuitem") && this.#Dt(t) : i && i.contains(t.target) || s && s.contains(t.target) || r && r.contains(t.target) || this.#Rt(t)) } #Tt(t) { this.collapse() } async#$t(o) { if (1 < o.buttons) o.preventDefault(); else if (this.querySelector(":scope > dialog[open]")) o.preventDefault(); else if (!1 !== this.contains(o.target)) { if (this.setPointerCapture(o.pointerId), o.preventDefault(), !1 === this.matches(":focus")) { let t = Ne(this.parentNode, "*[tabindex]:not(a)"); this.addEventListener("pointerup", () => { t ? t.focus() : this.blur() }, { once: !0 }) } if (!1 === this.#at() && !1 === this.#lt() && !1 === this.#Ct()) { let e = Date.now(), i = !0, s = parseInt(getComputedStyle(this).getPropertyValue("--min-pressed-time") || "150ms"); this.addEventListener("pointerup", async () => { i = !1; var t = Date.now() - e; t < s && await Se(s - t), this.removeAttribute("pressed") }, { once: !0 }), (async () => { var t; this.ownerButtons ? 0 !== this.ownerButtons.tracking && 2 !== this.ownerButtons.tracking && (1 !== this.ownerButtons.tracking || !1 !== this.toggled && !this.mixed) ? 3 === this.ownerButtons.tracking && (t = [...this.ownerButtons.querySelectorAll(":scope > x-button, :scope > x-box > x-button")].filter(t => t.toggled), (!1 === this.toggled || 1 < t.length) && await Se(10)) : await Se(10) : this.togglable && await Se(10), i && this.setAttribute("pressed", "") })() } this.#at() ? "touch" !== o.pointerType && this.#vt() : this.#lt() ? "touch" !== o.pointerType && this.#yt() : this.#Ct() && this.#St(); var a = getComputedStyle(this).getPropertyValue("--trigger-effect").trim(); if ("ripple" === a) { let t = this.#M.ripples.getBoundingClientRect(), e = 1.5 * He(t.width, t.height), i = o.clientY - t.y - e / 2, s = o.clientX - t.x - e / 2, r = new Promise(t => this.addEventListener("pointerup", t, { once: !0 })), n = !0; !1 === this.expandable && (this.ownerButtons ? 0 === this.ownerButtons.tracking || 2 === this.ownerButtons.tracking || 1 === this.ownerButtons.tracking && !1 === this.toggled ? n = !1 : 3 === this.ownerButtons.tracking && (o = [...this.ownerButtons.querySelectorAll(":scope > x-button, :scope > x-box > x-button")].filter(t => t.toggled), (!1 === this.toggled || 1 < o.length) && (n = !1)) : this.togglable && (n = !1)); let a = Be("div"); a.setAttribute("part", "ripple"), a.setAttribute("class", "ripple pointer-down-ripple"), a.setAttribute("style", `width: ${e}px; height: ${e}px; top: ${i}px; left: ${s}px;`), this.#M.ripples.append(a), this.#M.ripples.style.contain = "strict"; o = a.animate({ transform: ["scale3d(0, 0, 0)", "none"] }, { duration: 300, easing: "cubic-bezier(0.4, 0, 0.2, 1)" }); await r, n && (await o.finished, await a.animate({ opacity: [getComputedStyle(a).opacity || "0", "0"] }, { duration: 300, easing: "cubic-bezier(0.4, 0, 0.2, 1)" }).finished), a.remove() } else if ("unbounded-ripple" === a) { let t = this.#M.ripples.getBoundingClientRect(), e = 1.25 * t.height, i = t.y + t.height / 2 - t.y - e / 2, s = t.x + t.width / 2 - t.x - e / 2, r = new Promise(t => this.addEventListener("pointerup", t, { once: !0 })), n = Be("div"); n.setAttribute("part", "ripple"), n.setAttribute("class", "ripple pointer-down-ripple"), n.setAttribute("style", `width: ${e}px; height: ${e}px; top: ${i}px; left: ${s}px;`), this.#M.ripples.append(n), this.#M.ripples.style.contain = "none", n.hidden = !0, await Se(20), n.hidden = !1; o = n.animate({ transform: ["scale(0)", "scale(1)"] }, { duration: 200, easing: "cubic-bezier(0.4, 0, 0.2, 1)" }), a = (await r, await o.finished, n.animate({ opacity: [getComputedStyle(n).opacity || "0", "0"] }, { duration: 200, easing: "cubic-bezier(0.4, 0, 0.2, 1)" })); await a.finished, n.remove() } } } async#Rt(t) { let e = this.querySelector(":scope > x-menu, :scope > x-popover"); if (e) { if (e.hasAttribute("closing")) return; e.focus() } if (!1 === this.#Ct() && (this.#At() ? this.#Et() : this.#Mt() && this.#Lt()), this.#ut && "touch" === this.#ut.pointerType && (this.#at() ? this.#vt() : this.#lt() && this.#yt()), this.togglable && !1 === t.defaultPrevented && (this.removeAttribute("pressed"), this.toggled = !this.toggled, this.dispatchEvent(new CustomEvent("toggle"))), null === this.#M.ripples.querySelector(".pointer-down-ripple")) { t = getComputedStyle(this).getPropertyValue("--trigger-effect").trim(); if ("ripple" === t) { let t = this.#M.ripples.getBoundingClientRect(), e = 1.5 * He(t.width, t.height), i = t.y + t.height / 2 - t.y - e / 2, s = t.x + t.width / 2 - t.x - e / 2, r = !0, n = (this.ownerButtons ? (0 === this.ownerButtons.tracking || 2 === this.ownerButtons.tracking || 3 === this.ownerButtons.tracking || 1 === this.ownerButtons.tracking && !0 === this.toggled) && (r = !1) : this.togglable && (r = !1), Be("div")); n.setAttribute("part", "ripple"), n.setAttribute("class", "ripple click-ripple"), n.setAttribute("style", `width: ${e}px; height: ${e}px; top: ${i}px; left: ${s}px;`), this.#M.ripples.append(n), this.#M.ripples.style.contain = "strict"; var a = n.animate({ transform: ["scale3d(0, 0, 0)", "none"] }, { duration: 300, easing: "cubic-bezier(0.4, 0, 0.2, 1)" }); r && (await a.finished, await n.animate({ opacity: [getComputedStyle(n).opacity || "0", "0"] }, { duration: 300, easing: "cubic-bezier(0.4, 0, 0.2, 1)" }).finished), n.remove() } else if ("unbounded-ripple" === t) { let t = this.#M.ripples.getBoundingClientRect(), e = 1.35 * t.height, i = t.y + t.height / 2 - t.y - e / 2, s = t.x + t.width / 2 - t.x - e / 2, r = Be("div"); r.setAttribute("part", "ripple"), r.setAttribute("class", "ripple"), r.setAttribute("style", `width: ${e}px; height: ${e}px; top: ${i}px; left: ${s}px;`), this.#M.ripples.append(r), this.#M.ripples.style.contain = "none", await r.animate({ transform: ["scale3d(0, 0, 0)", "none"] }, { duration: 300, easing: "cubic-bezier(0.4, 0, 0.2, 1)" }).finished, await r.animate({ opacity: [getComputedStyle(r).opacity || "0", "0"] }, { duration: 300, easing: "cubic-bezier(0.4, 0, 0.2, 1)" }).finished, r.remove() } } } #Dt(t) { t = t.target.closest("x-menuitem"); this.querySelector(":scope > x-menu").hasAttribute("closing") || this.collapse(t.whenTriggerEnd) } #bt(t) { !1 === t.defaultPrevented && ("Enter" === t.code || "Space" === t.code ? this.#at() ? (t.preventDefault(), this.#vt().then(() => this.querySelector(":scope > x-menu").focusFirstMenuItem())) : this.#lt() ? (t.preventDefault(), this.#yt()) : this.#At() ? (t.preventDefault(), this.#Et()) : this.#Mt() ? (t.preventDefault(), this.#Lt()) : this.matches(":focus") && (this.#Ct() ? this.#St() : this.#kt() ? this.#zt() : (t.preventDefault(), this.click())) : "ArrowDown" === t.code ? this.#at() ? (this.querySelector(":scope > x-menu"), t.preventDefault(), this.#vt().then(() => this.querySelector(":scope > x-menu").focusFirstMenuItem())) : this.#lt() ? (t.preventDefault(), this.#yt()) : (t.preventDefault(), this.click()) : "ArrowUp" === t.code ? this.#at() ? (t.preventDefault(), this.#vt().then(() => this.querySelector(":scope > x-menu").focusLastMenuItem())) : this.#lt() ? (t.preventDefault(), this.#yt()) : (t.preventDefault(), this.click()) : "Escape" === t.code && (this.#kt() || this.#Ct()) && (t.preventDefault(), this.collapse())) } } customElements.define("x-button", Ue); let qe = Array["isArray"]; class Ke extends HTMLElement { static #A = Mt`<template><slot></slot></template>`; static #L = Tt`:host{display:flex;flex-flow:row;align-items:center;justify-content:flex-start;box-sizing:border-box;width:fit-content}:host([hidden]){display:none}`; get tracking() { return this.hasAttribute("tracking") ? parseInt(this.getAttribute("tracking")) : -1 } set tracking(t) { this.setAttribute("tracking", t) } get vertical() { return this.hasAttribute("vertical") } set vertical(t) { !0 === t ? this.setAttribute("vertical", "") : this.removeAttribute("vertical") } get value() { return 2 === this.tracking || 3 === this.tracking ? this.#Pt().filter(t => t.toggled).map(t => t.value).filter(t => null != t) : 1 === this.tracking || 0 === this.tracking ? (t = this.#Pt().find(t => t.toggled)) && void 0 !== t.value ? t.value : null : -1 === this.tracking ? null : void 0; var t } set value(i) { if (2 === this.tracking || 3 === this.tracking) { var t = this.#Pt(); if (qe(i)) for (var e of t) e.toggled = i.includes(e.value); else for (var s of t) s.toggled = s.value === i } else if (1 === this.tracking || 0 === this.tracking) { let t = this.#Pt(), e = t.find(t => t.value === i); for (var r of t) r.toggled = r === e } } #T = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [Ke.#L], this.#T.append(document.importNode(Ke.#A.content, !0)), this.addEventListener("click", t => this.#I(t), !0), this.addEventListener("keydown", t => this.#bt(t)) } connectedCallback() { for (var t of this.children) if ("x-button" === t.localName) { "none" !== getComputedStyle(t).boxShadow ? this.setAttribute("hasboxshadow", "") : this.removeAttribute("hasboxshadow"); break } } #Pt() { return [...this.querySelectorAll(":scope > x-button, :scope > x-box > x-button")] } #I(i) { if (!(1 < i.buttons)) { let e = i.target.closest("x-button"); if (e && !1 === e.disabled && !1 === e.expandable) { let t = this.#Pt().filter(t => t !== e); if (0 === this.tracking) { e.mixed || (e.toggled = !e.toggled), e.mixed = !1; for (var s of t) s.toggled = !1, s.mixed = !1; this.dispatchEvent(new CustomEvent("toggle", { bubbles: !0, detail: e })) } else if (1 === this.tracking) { if (!1 === e.toggled || !0 === e.mixed) { e.toggled = !0, e.mixed = !1; for (var r of t) r.toggled = !1, r.mixed = !1; this.dispatchEvent(new CustomEvent("toggle", { bubbles: !0, detail: e })) } } else 2 === this.tracking ? (e.mixed ? e.mixed = !1 : e.toggled = !e.toggled, this.dispatchEvent(new CustomEvent("toggle", { bubbles: !0, detail: e }))) : 3 === this.tracking && (i = t.filter(t => !0 === t.toggled), (!1 === e.toggled || 0 < i.length) && (e.mixed ? e.mixed = !1 : e.toggled = !e.toggled, this.dispatchEvent(new CustomEvent("toggle", { bubbles: !0, detail: e })))) } } } #bt(t) { t = t.key; if ("ArrowRight" === t) { let t = [...this.children].find(t => t.matches(":focus")); t && (t.nextElementSibling ? t.nextElementSibling.focus() : t !== t.parentElement.firstElementChild && t.parentElement.firstElementChild.focus()) } else if ("ArrowLeft" === t) { let t = [...this.children].find(t => t.matches(":focus")); t && (t.previousElementSibling ? t.previousElementSibling.focus() : t !== t.parentElement.lastElementChild && t.parentElement.lastElementChild.focus()) } } } customElements.define("x-buttons", Ke); class Ve extends HTMLElement { static #A = Mt`<template><slot id="slot"></slot></template>`; static #L = Tt`:host{display:block;width:100%;min-width:20px;min-height:48px;box-sizing:border-box;margin:30px 0}:host([hidden]){display:none}#slot{border-radius:inherit}`; #T = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [Ve.#L], this.#T.append(document.importNode(Ve.#A.content, !0)) } } customElements.define("x-card", Ve); class Xe extends HTMLElement { static observedAttributes = ["toggled", "disabled", "size"]; static #A = Mt`<template><main id="main"><div id="indicator" part="indicator"><div id="ripples"></div><svg id="checkmark" viewBox="0 0 100 100" preserveAspectRatio="none"><path></path></svg></div><div id="description"><slot></slot></div></main></template>`; static #L = Tt`:host{display:block;width:fit-content;--trigger-effect:none}:host([disabled]){opacity:.4;pointer-events:none}:host([hidden]){display:none}:host(:focus){outline:0}#main{display:flex;align-items:center}#indicator{position:relative;width:19px;height:19px;box-sizing:border-box;border:2px solid currentColor;overflow:hidden;d:path("M 0 0 L 100 0 L 100 100 L 0 100 L 0 0 Z M 95 23 L 86 13 L 37 66 L 13.6 41 L 4.5 51 L 37 85 L 95 23 Z")}:host([mixed]) #indicator{d:path("M 0 0 L 100 0 L 100 100 L 0 100 Z M 87 42.6 L 13 42.6 L 13 57.4 L 87 57.4 Z")}#checkmark{position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;d:inherit;transition-property:opacity;transition-timing-function:inherit;transition-duration:inherit}:host([mixed]) #checkmark{opacity:1}:host([toggled]) #checkmark{opacity:1}#checkmark path{fill:currentColor;d:inherit}#ripples{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none}#ripples .ripple{position:absolute;top:0;left:0;width:100%;height:100%;background:currentColor;opacity:.15;z-index:-1;will-change:opacity,transform;border-radius:999px;transform:scale(2.6)}#description{flex:1}`; get value() { return this.hasAttribute("value") ? this.getAttribute("value") : null } set value(t) { null === t ? this.removeAttribute("value") : this.setAttribute("value", t) } get toggled() { return this.hasAttribute("toggled") } set toggled(t) { t ? this.setAttribute("toggled", "") : this.removeAttribute("toggled") } get mixed() { return this.hasAttribute("mixed") } set mixed(t) { t ? this.setAttribute("mixed", "") : this.removeAttribute("mixed") } get disabled() { return this.hasAttribute("disabled") } set disabled(t) { t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled") } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } #T = null; #M = {}; #ct = 0; #D = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [Xe.#L], this.#T.append(document.importNode(Xe.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t; this.addEventListener("pointerdown", t => this.#pt(t)), this.addEventListener("click", t => this.#I(t)), this.addEventListener("keydown", t => this.#bt(t)) } connectedCallback() { Me.addEventListener("sizechange", this.#D = () => this.#F()), this.#xt(), this.#F() } disconnectedCallback() { Me.removeEventListener("sizechange", this.#D) } attributeChangedCallback(t) { "toggled" === t ? this.#It() : "disabled" === t ? this.#Ot() : "size" === t && this.#F() } #xt() { this.setAttribute("role", "checkbox"), this.setAttribute("aria-checked", this.mixed ? "mixed" : this.toggled), this.setAttribute("aria-disabled", this.disabled), this.disabled ? (this.#ct = 0 < this.tabIndex ? this.tabIndex : 0, this.tabIndex = -1) : (this.tabIndex < 0 && (this.tabIndex = 0 < this.#ct ? this.#ct : 0), this.#ct = 0) } #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } #It() { this.setAttribute("aria-toggled", this.mixed ? "mixed" : this.toggled) } #Ot() { this.#xt() } #pt(i) { if (1 < i.buttons) i.preventDefault(); else { if (!1 === this.matches(":focus")) { i.preventDefault(); let t = Ne(this.parentNode, "[tabindex]"); t && t.focus() } if ("ripple" === getComputedStyle(this).getPropertyValue("--trigger-effect").trim()) { let t = Be("div"), e = (t.setAttribute("class", "ripple pointer-down-ripple"), this.#M.ripples.append(t), t.animate({ transform: ["scale(0)", "scale(2.6)"] }, { duration: 200, easing: "cubic-bezier(0.4, 0, 0.2, 1)" })); this.setPointerCapture(i.pointerId), this.addEventListener("pointerup", async () => { await e.finished, await t.animate({ opacity: [getComputedStyle(t).opacity, "0"] }, { duration: 200, easing: "cubic-bezier(0.4, 0, 0.2, 1)" }).finished, t.remove() }, { once: !0 }) } } } async#I(t) { if (this.mixed ? this.mixed = !1 : this.toggled = !this.toggled, this.dispatchEvent(new CustomEvent("toggle", { bubbles: !0 })), null === this.#M.ripples.querySelector(".pointer-down-ripple") && "ripple" === getComputedStyle(this).getPropertyValue("--trigger-effect").trim()) { let t = Be("div"); t.setAttribute("class", "ripple"), this.#M.ripples.append(t), await t.animate({ transform: ["scale(0)", "scale(2.6)"] }, { duration: 300, easing: "cubic-bezier(0.4, 0, 0.2, 1)" }).finished, await t.animate({ opacity: [getComputedStyle(t).opacity, "0"] }, { duration: 300, easing: "cubic-bezier(0.4, 0, 0.2, 1)" }).finished, t.remove() } } #bt(t) { "Enter" !== t.code && "Space" !== t.code || (t.preventDefault(), this.click()) } } customElements.define("x-checkbox", Xe); class Ze extends HTMLElement { static observedAttributes = ["value", "disabled", "size"]; static #A = Mt`<template><input tabindex="-1" id="input" type="color" value="#ffffff"><slot></slot></template>`; static #L = Tt`:host{display:block;width:32px;height:32px;box-sizing:border-box;position:relative;overflow:hidden;background-color:#fff;background-size:10px 10px;background-position:0 0,0 5px,5px -5px,-5px 0;background-image:linear-gradient(45deg,#d6d6d6 25%,transparent 25%),linear-gradient(-45deg,#d6d6d6 25%,transparent 25%),linear-gradient(45deg,transparent 75%,#d6d6d6 75%),linear-gradient(-45deg,transparent 75%,#d6d6d6 75%)}:host([hidden]){display:none}:host([disabled]){pointer-events:none;opacity:.4}::slotted(x-popover){width:190px;height:auto;padding:12px 12px}#input{display:flex;width:100%;height:100%;box-sizing:border-box;border:none;background:0 0;padding:0;opacity:0;-webkit-appearance:none}#input::-webkit-color-swatch-wrapper{padding:0}#input::-webkit-color-swatch{border:none}`; get value() { return this.hasAttribute("value") ? this.getAttribute("value") : "#ffffff" } set value(t) { this.setAttribute("value", t) } get disabled() { return this.hasAttribute("disabled") } set disabled(t) { t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled") } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } #T = null; #M = {}; #Ft = !1; #dt = !1; #D = null; #ct = 0; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [Ze.#L], this.#T.append(document.importNode(Ze.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t; this.addEventListener("click", t => this.#I(t)), this.addEventListener("keydown", t => this.#bt(t)), this.addEventListener("pointerdown", t => this.#pt(t)), this.addEventListener("change", t => this.#Bt(t)), this.#M.input.addEventListener("change", t => this.#Nt(t)) } connectedCallback() { let t = this.querySelector("x-wheelcolorpicker, x-rectcolorpicker, x-barscolorpicker"); t && t.setAttribute("value", y(this.value, "rgba")), this.#xt(), this.#F(), this.#jt(), Me.addEventListener("sizechange", this.#D = () => this.#F()) } disconnectedCallback() { Me.removeEventListener("sizechange", this.#D) } attributeChangedCallback(t) { "value" === t ? this.#Q() : "disabled" === t ? this.#Ot() : "size" === t && this.#tt() } async#Ht() { if (!1 === this.hasAttribute("expanded")) { let t = this.querySelector("x-popover"); t && (this.#dt = this.matches(":focus"), this.setAttribute("expanded", ""), await t.open(this), t.focus()) } } async#Ut(t = 0) { if (this.hasAttribute("expanded")) { let t = this.querySelector("x-popover"); if (t) { if (t.setAttribute("closing", ""), await t.close(), this.removeAttribute("expanded"), this.#dt) this.focus(); else { let t = Ne(this.parentNode, "[tabindex]"); t && t.focus() } t.removeAttribute("closing") } } } #jt() { var [t, e, i, s] = (new E).parse(this.value, "rgba"); this.#M.input.value = v([t, e, i, s], "rgba", "hex"), this.#M.input.style.opacity = s } #xt() { this.setAttribute("aria-disabled", this.disabled), this.disabled ? (this.#ct = 0 < this.tabIndex ? this.tabIndex : 0, this.tabIndex = -1) : (this.tabIndex < 0 && (this.tabIndex = 0 < this.#ct ? this.#ct : 0), this.#ct = 0) } #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } #Q() { this.#Ft || this.#jt(); let t = [...this.querySelectorAll("*")].find(t => t.localName.endsWith("colorpicker")); t && t.getAttribute("value") !== this.getAttribute("value") && t.setAttribute("value", this.getAttribute("value")) } #Ot() { this.#xt() } #tt() { this.#F() } #Bt(t) { t.target !== this && (this.value = y(t.target.value, "rgba"), this.#jt()) } #Nt() { !1 === this.#Ft && (this.#Ft = !0, this.dispatchEvent(new CustomEvent("changestart"))), this.value = this.#M.input.value, this.dispatchEvent(new CustomEvent("change")), this.#qt() } #qt = Le(() => { this.#Ft && (this.#Ft = !1, this.value = this.#M.input.value, this.dispatchEvent(new CustomEvent("changeend"))) }, 400); #pt(t) { t.target === this && t.preventDefault() } #I(t) { var e = this.querySelector(":scope > x-popover"); e && (e.opened ? (!1 === e.modal && t.target === this || !0 === e.modal && "x-backdrop" === t.target.localName) && (t.preventDefault(), this.#Ut()) : (t.preventDefault(), this.#Ht())) } #bt(t) { var e; "Enter" === t.code || "Space" === t.code ? (e = this.querySelector("x-popover"), t.preventDefault(), t.stopPropagation(), e ? this.hasAttribute("expanded") ? this.#Ut() : this.#Ht() : this.#M.input.click()) : "Escape" === t.code ? this.querySelector("x-popover") && this.hasAttribute("expanded") && (t.preventDefault(), this.#Ut()) : "Tab" === t.code && this.hasAttribute("expanded") && t.preventDefault() } } customElements.define("x-colorselect", Ze); class Ge extends HTMLElement { static #A = Mt`<template><slot></slot></template>`; static #L = Tt`:host{display:block;position:fixed;width:0;height:0;z-index:1001}`; get disabled() { return this.hasAttribute("disabled") } set disabled(t) { t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled") } #T = null; #M = {}; #Kt = null; #Vt = null; #Xt = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [Ge.#L], this.#T.append(document.importNode(Ge.#A.content, !0)), this.#M.backdrop = Be("x-backdrop"), this.#M.backdrop.style.background = "rgba(0, 0, 0, 0)", this.#M.backdrop.addEventListener("contextmenu", t => this.#Zt(t)), this.#M.backdrop.addEventListener("pointerdown", t => this.#Tt(t)), this.addEventListener("blur", t => this.#Gt()), this.addEventListener("keydown", t => this.#bt(t), !0), this.addEventListener("click", t => this.#I(t)) } connectedCallback() { this.#Kt = this.parentElement || this.parentNode.host, window.addEventListener("blur", this.#Vt = () => { this.#Gt() }), this.#Kt.addEventListener("contextmenu", this.#Xt = t => { this.#Wt(t) }) } disconnectedCallback() { window.removeEventListener("blur", this.#Vt), this.#Kt.removeEventListener("contextmenu", this.#Xt), this.#Kt = null } open(t, e) { let i = this.querySelector("x-menu"); !1 === i.opened && (i.openAtPoint(t, e), this.#M.backdrop.ownerElement = i, this.#M.backdrop.show(!1), i.focus()) } close() { return new Promise(async t => { this.#M.backdrop.hide(!1); let e = this.querySelector("x-menu"); if (e && !0 === e.opened) { await e.close(); let t = Ne(this.parentNode, "[tabindex]"); t && t.focus() } t() }) } #Gt() { this.close() } #Wt(t) { !1 === this.disabled && (t.preventDefault(), this.open(t.clientX, t.clientY)) } #Zt(i) { i.preventDefault(), i.stopImmediatePropagation(), this.close().then(() => { let t = ((i, s) => { let r = document.elementFromPoint(i, s); if (r) for (; ;) { let e = r.shadowRoot || r._shadowRoot; if (!e) break; { let t = e.elementFromPoint(i, s); if (!(t = t.getRootNode() !== e ? null : t) || t === r) break; r = t } } return r })(i.clientX, i.clientY), e = new MouseEvent(i.type, i); t.dispatchEvent(e) }) } #Tt(t) { t.buttons <= 1 && (t.preventDefault(), t.stopImmediatePropagation(), this.close()) } async#I(t) { let e = t.target.closest("x-menuitem"); if (e && !1 === e.disabled) { let t = e.querySelector("x-menu"); t ? t.opened ? t.close() : t.openNextToElement(e, "horizontal") : (this.setAttribute("closing", ""), await e.whenTriggerEnd, await this.close(), this.removeAttribute("closing")) } } #bt(t) { "Escape" === t.key ? this.querySelector("x-menu").opened && (t.preventDefault(), this.close()) : "Tab" === t.key && (t.preventDefault(), t.stopPropagation(), this.querySelector("x-menu").focusNextMenuItem()) } } customElements.define("x-contextmenu", Ge); class We extends HTMLElement { static observedAttributes = ["href", "size"]; static #A = Mt`<template><svg id="svg" preserveAspectRatio="none" viewBox="0 0 100 100" width="0px" height="0px"></svg></template>`; static #L = Tt`:host{display:block;color:currentColor;display:flex;align-items:center;justify-content:center;width:17px;height:17px}:host([disabled]){opacity:.5}:host([hidden]){display:none}#svg{width:100%;height:100%;fill:currentColor;stroke:none;overflow:inherit;pointer-events:none}`; get href() { return this.hasAttribute("href") ? this.getAttribute("href") : "" } set href(t) { this.setAttribute("href", t) } get disabled() { return this.hasAttribute("disabled") } set disabled(t) { t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled") } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } #T = null; #M = {}; #Yt = null; #D = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [We.#L], this.#T.append(document.importNode(We.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t } connectedCallback() { Me.addEventListener("iconsetschange", this.#Yt = () => { this.#J() }), Me.addEventListener("sizechange", this.#D = () => { this.#F() }), this.#F() } disconnectedCallback() { Me.removeEventListener("iconsetschange", this.#Yt), Me.removeEventListener("sizechange", this.#D) } attributeChangedCallback(t, e, i) { e !== i && ("href" === t ? this.#J() : "size" === t && this.#F()) } async#J() { let s = null, t = this.href.trim(); if ("" !== t) { let e = null, i = null; var r; if (t.includes("#") && ("" !== (r = t.split("#"))[0] && (e = r[0]), "" !== r[1] && (i = r[1])), null !== i) if (null === e) await Me.whenIconsetsReady, s = Me.queryIcon("#" + CSS.escape(i)); else { let t = await Rt(e); t && (s = t.querySelector("#" + CSS.escape(i))) } } s ? (this.#M.svg.setAttribute("viewBox", s.getAttribute("viewBox")), this.#M.svg.innerHTML = s.innerHTML) : this.#M.svg.innerHTML = "" } #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } } customElements.define("x-icon", We); class Ye extends HTMLElement { static observedAttributes = ["type", "value", "spellcheck", "maxlength", "readonly", "disabled", "validation", "size"]; static #A = Mt`<template><main id="main"><slot></slot><input id="input" spellcheck="false" part="input"></main></template>`; static #L = Tt`:host{display:block;position:relative;max-width:160px;height:32px;box-sizing:border-box;background:#fff;font-size:12.5px}:host(:focus){z-index:10}:host(:hover){cursor:text}:host([mixed]){color:rgba(0,0,0,.7)}:host([disabled]){pointer-events:none;opacity:.5}:host([hidden]){display:none}::selection{color:var(--selection-color);background-color:var(--selection-background-color)}:host([error]) ::selection{color:#fff;background-color:#d50000}#main{display:flex;align-items:center;width:100%;height:100%}#input{width:100%;height:100%;padding:0 6px;box-sizing:border-box;color:inherit;background:0 0;border:none;outline:0;font-family:inherit;font-size:inherit;font-weight:inherit;text-align:inherit;cursor:inherit}#input:-webkit-autofill{z-index:1}#input:-internal-autofill-previewed,#input:-internal-autofill-selected{-webkit-box-shadow:var(--autofill-background-color) 0 0 0 30px inset}:host(:not(:focus)) ::selection{color:inherit;background:0 0}`; get type() { return this.hasAttribute("type") ? this.getAttribute("type") : "text" } set type(t) { this.setAttribute("type", t) } get value() { return this.#M.input.value } set value(t) { this.#M.input.value !== t && (this.matches(":focus") ? (this.#M.input.selectionStart = 0, this.#M.input.selectionEnd = this.#M.input.value.length, document.execCommand("insertText", !1, t)) : this.#M.input.value = t, "instant" === this.validation ? this.reportValidity() : "auto" !== this.validation && "manual" !== this.validation || (this.#_t || this.#Jt) && this.reportValidity(), this.#Qt()) } get spellcheck() { return this.hasAttribute("spellcheck") } set spellcheck(t) { t ? this.setAttribute("spellcheck", "") : this.removeAttribute("spellcheck") } get minLength() { return this.hasAttribute("minlength") ? parseInt(this.getAttribute("minlength")) : 0 } set minLength(t) { this.setAttribute("minlength", t) } get maxLength() { return this.hasAttribute("maxlength") ? parseInt(this.getAttribute("maxlength")) : 1 / 0 } set maxLength(t) { this.setAttribute("maxlength", t) } get required() { return this.hasAttribute("required") } set required(t) { t ? this.setAttribute("required", "") : this.removeAttribute("required") } get readOnly() { return this.hasAttribute("readonly") } set readOnly(t) { !0 === t ? this.setAttribute("readonly", t) : this.removeAttribute("readonly") } get mixed() { return this.hasAttribute("mixed") } set mixed(t) { t ? this.setAttribute("mixed", "") : this.removeAttribute("mixed") } get disabled() { return this.hasAttribute("disabled") } set disabled(t) { t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled") } get validation() { return this.hasAttribute("validation") ? this.getAttribute("validation") : "auto" } set validation(t) { this.setAttribute("validation", t) } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } get empty() { return this.hasAttribute("empty") } get error() { return this.hasAttribute("error") } #T = null; #M = {}; #ct = 0; #_t = null; #Jt = null; #D = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed", delegatesFocus: !0 }), this.#T.adoptedStyleSheets = [Ye.#L], this.#T.append(document.importNode(Ye.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t; this.addEventListener("click", t => this.#I(t)), this.addEventListener("pointerenter", () => this.#mt()), this.addEventListener("pointerleave", () => this.#gt()), this.addEventListener("focusin", t => this.#te(t)), this.addEventListener("focusout", t => this.#ee(t)), this.addEventListener("keydown", t => this.#bt(t)), this.#M.input.addEventListener("change", t => this.#Nt(t)), this.#M.input.addEventListener("input", t => this.#ie(t)), this.#M.input.addEventListener("search", t => this.#se(t)) } connectedCallback() { this.#xt(), this.#F(), this.#Qt(), "instant" === this.validation ? this.reportValidity() : "auto" !== this.validation && "manual" !== this.validation || (this.#_t || this.#Jt) && this.reportValidity(), Me.addEventListener("sizechange", this.#D = () => this.#F()) } disconnectedCallback() { Me.removeEventListener("sizechange", this.#D) } attributeChangedCallback(t) { "type" === t ? this.#ne() : "value" === t ? this.#Q() : "spellcheck" === t ? this.#oe() : "maxlength" === t ? this.#re() : "readonly" === t ? this.#he() : "disabled" === t ? this.#Ot() : "validation" === t ? this.#ae() : "size" === t && this.#le() } selectAll() { this.#M.input.select() } clear() { this.value = "", this.#_t = null, this.#Jt = null, this.#de() } reportValidity() { var t = new CustomEvent("beforevalidate", { bubbles: !1, cancelable: !0 }); return this.dispatchEvent(t), !1 === t.defaultPrevented && (this.value.length < this.minLength ? this.#_t = { href: "#entered-text-is-too-short" } : this.value.length > this.maxLength ? this.#_t = { href: "#entered-text-is-too-long" } : this.required && 0 === this.value.length ? this.#_t = { href: "#required-field" } : "email" === this.type && !1 === this.#M.input.validity.valid ? this.#_t = { href: "#invalid-email" } : "url" === this.type && !1 === this.#M.input.validity.valid ? this.#_t = { href: "#invalid-url" } : "color" === this.type && !1 === (t => { try { (new E).parse(t) } catch (t) { return !1 } return !0 })(this.#M.input.value) ? this.#_t = { href: "#invalid-color" } : this.#_t = null, this.#de()), null === this.#_t && null === this.#Jt } setCustomValidity(t) { this.#Jt = "" === t ? null : t, this.#de() } #de() { var e, i = this.#Jt || this.#_t; i ? this.setAttribute("error", "") : this.removeAttribute("error"); { let t = this.querySelector(':scope > x-tooltip[type="error"]'); i && this.matches(":focus") ? (t || ((t = Be("x-tooltip")).setAttribute("type", "error"), this.append(t)), i.href ? (e = i.args ? Object.entries(i.args).map(([t, e]) => t + ":" + e).join(",") : "", t.innerHTML = `<x-message href="${i.href}" args="${e}"></x-message>`) : t.innerHTML = i, Se(10).then(() => { t.open(this) })) : t && t.close().then(() => t.remove()) } } #Qt() { 0 === this.value.length ? this.setAttribute("empty", "") : this.removeAttribute("empty") } #xt() { this.setAttribute("role", "input"), this.setAttribute("aria-disabled", this.disabled), this.setAttribute("aria-readonly", this.readOnly), this.disabled ? (this.#ct = 0 < this.tabIndex ? this.tabIndex : 0, this.tabIndex = -1) : (this.tabIndex < 0 && (this.tabIndex = 0 < this.#ct ? this.#ct : 0), this.#ct = 0) } #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } #ne() { "color" === this.type ? this.#M.input.type = "text" : this.#M.input.type = this.type } #Q() { this.value = this.hasAttribute("value") ? this.getAttribute("value") : "", this.matches(":focus") && this.selectAll() } #oe() { this.#M.input.spellcheck = this.spellcheck } #re() { this.#M.input.maxLength = this.maxLength } #he() { this.#M.input.readOnly = this.readOnly, this.#xt() } #Ot() { this.#M.input.disabled = this.disabled, this.#xt() } #ae() { "instant" === this.validation ? this.reportValidity() : "auto" !== this.validation && "manual" !== this.validation || (this.#_t || this.#Jt) && this.reportValidity() } #le() { this.#F() } #I() { this.#de() } #mt() { let t = this.querySelector(":scope > x-tooltip"); t && !1 === t.disabled && t.open(this) } #gt() { let t = this.querySelector(":scope > x-tooltip"); t && t.close() } #te() { this.#de(), this.dispatchEvent(new CustomEvent("textinputmodestart", { bubbles: !0, composed: !0 })) } #ee() { this.dispatchEvent(new CustomEvent("textinputmodeend", { bubbles: !0, composed: !0 })), "auto" === this.validation || "instant" === this.validation ? this.reportValidity() : "manual" === this.validation && this.#de() } #bt(t) { "Enter" === t.key && (document.execCommand("selectAll"), "instant" !== this.validation && "auto" !== this.validation && "manual" !== this.validation || this.reportValidity()) } #ie(t) { "instant" === this.validation ? this.reportValidity() : "auto" !== this.validation && "manual" !== this.validation || (this.#_t || this.#Jt) && this.reportValidity(), t.stopPropagation(), this.#Qt(), this.dispatchEvent(new CustomEvent("input", { bubbles: !0 })) } #Nt() { "search" !== this.type && this.dispatchEvent(new CustomEvent("change", { bubbles: !0 })) } #se() { this.dispatchEvent(new CustomEvent("change", { bubbles: !0 })) } } customElements.define("x-input", Ye); class _e extends HTMLElement { static #A = Mt`<template><slot></slot></template>`; static #L = Tt`:host{display:block;line-height:1.2;user-select:none;box-sizing:border-box}:host([disabled]){opacity:.5}:host([hidden]){display:none}slot{text-decoration:inherit}`; get value() { return this.hasAttribute("value") ? this.getAttribute("value") : null } set value(t) { null === t ? this.removeAttribute("value") : this.setAttribute("value", t) } get disabled() { return this.hasAttribute("disabled") } set disabled(t) { t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled") } #T = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [_e.#L], this.#T.append(document.importNode(_e.#A.content, !0)) } } customElements.define("x-label", _e); let { isFinite: Je, isNaN: Qe, parseFloat: ti } = Number; class ei extends HTMLElement { static observedAttributes = ["href", "args", "autocapitalize", "ellipsis"]; get href() { return this.hasAttribute("href") ? this.getAttribute("href") : "" } set href(t) { this.setAttribute("href", t) } get args() { let i = Object.create(null), t = this.hasAttribute("args") ? this.getAttribute("args").trim() : ""; if ("" !== t) for (var s of t.split(",")) { let [t, e] = s.split(":"); t = t.trim(), e = e.trim(); var s = parseFloat(e), r = 0 <= e - s + 1; i[t] = r ? s : e } return i } set args(e) { var t = Object.keys(e).map(t => t + ": " + e[t]).join(", "); 0 === e.length ? this.removeAttribute("args") : this.setAttribute("args", t) } get autocapitalize() { return !!this.hasAttribute("autocapitalize") } set autocapitalize(t) { t ? this.setAttribute("autocapitalize", "") : this.removeAttribute("autocapitalize") } get ellipsis() { return this.hasAttribute("ellipsis") } set ellipsis(t) { t ? this.setAttribute("ellipsis", "") : this.removeAttribute("ellipsis") } get whenReady() { return new Promise(t => { null === this.#ue ? t() : this.#ue.push(t) }) } #ce = null; #pe = null; #ue = []; connectedCallback() { this.#J(), Me.addEventListener("localeschange", this.#ce = () => { this.#J() }), Me.addEventListener("themechange", this.#pe = () => { this.#J() }) } disconnectedCallback() { Me.removeEventListener("localeschange", this.#ce), Me.removeEventListener("themechange", this.#pe) } attributeChangedCallback(t, e, i) { e === i || !1 === this.isConnected || "href" !== t && "args" !== t && "autocapitalize" !== t && "ellipsis" !== t || this.#J() } async#J() { await Me.whenLocalesReady; var t = Me.queryMessage(this.href, this.args); if ("html" === t.format ? this.innerHTML = t.content + (this.ellipsis ? "…" : "") : !0 === this.autocapitalize && "titlecase" === Me.autocapitalize ? this.textContent = (t => { let s = /^(a|an|and|as|at|but|by|en|for|if|in|nor|of|on|or|per|the|to|v.?|vs.?|via)$/i, r = /([A-Za-z0-9\u00C0-\u00FF])/; return t.split(/([ :–—-])/).map((t, e, i) => -1 < t.search(s) && 0 !== e && e !== i.length - 1 && ":" !== i[e - 3] && ":" !== i[e + 1] && ("-" !== i[e + 1] || "-" === i[e - 1] && "-" === i[e + 1]) ? t.toLowerCase() : -1 < t.substr(1).search(/[A-Z]|\../) || ":" === i[e + 1] && "" !== i[e + 2] ? t : t.replace(r, t => t.toUpperCase())).join("") })(t.content) + (this.ellipsis ? "…" : "") : this.textContent = t.content + (this.ellipsis ? "…" : ""), null !== this.#ue) { for (var e of this.#ue) e(); this.#ue = null } } } customElements.define("x-message", ei); let ii = t => { let [e, i, ...s] = t.trim().split(" "); return [i, parseFloat(e), s.join(" ")] }, si = Math["abs"]; class ni extends HTMLElement { static observedAttributes = ["opened"]; static #A = Mt`<template><slot id="slot"></slot></template>`; static #L = Tt`:host{display:none;top:0;left:0;width:fit-content;padding:4px 0;z-index:1001;box-sizing:border-box;background:#fff;cursor:default;overflow:auto;flex-direction:column;-webkit-app-region:no-drag;--align:start;--scrollbar-background:rgba(0, 0, 0, 0.2);--scrollbar-width:6px;--open-transition:100 transform cubic-bezier(0.4, 0, 0.2, 1);--close-transition:200 opacity cubic-bezier(0.4, 0, 0.2, 1)}:host([animating]),:host([opened]){display:flex}:host(:focus){outline:0}:host-context([debug]):host(:focus){outline:2px solid red}::-webkit-scrollbar{max-width:var(--scrollbar-width);background:0 0}::-webkit-scrollbar-thumb{background-color:var(--scrollbar-background)}::-webkit-scrollbar-corner{display:none}`; get opened() { return this.hasAttribute("opened") } #T = null; #M = {}; #me = []; #ge = null; #be = null; #fe = 0; #xe = 0; #we = !1; #ve = !1; #ye = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [ni.#L], this.#T.append(document.importNode(ni.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t; this.addEventListener("pointerdown", t => this.#pt(t)), this.addEventListener("pointerover", t => this.#ke(t)), this.addEventListener("pointerout", t => this.#ze(t)), this.addEventListener("pointermove", t => this.#Ce(t)), this.addEventListener("keydown", t => this.#bt(t)), this.addEventListener("wheel", t => this.#Se(t), { passive: !1 }), this.addEventListener("scroll", t => this.#Ee(t), { passive: !0 }) } connectedCallback() { this.setAttribute("role", "menu"), this.setAttribute("aria-hidden", !this.opened), this.setAttribute("tabindex", "0") } attributeChangedCallback(t) { "opened" === t && this.#Ae() } openOverElement(h, d) { return new Promise(async t => { var a = this.querySelectorAll(":scope > x-menuitem"); if (0 < a.length) { this.#we = !0, this.#ye = Ee(), this.#Le(), this.setAttribute("opened", ""); let t = [...a].find(t => t.contains(d)) || a[0], e = this.getBoundingClientRect(), i = h.getBoundingClientRect(), s = d.getBoundingClientRect(), r = 0, n = 0; t.focus(), 0 === e.top && 0 === e.left || (r = -e.left, n = -e.top), this.style.left = i.x - (s.x - e.x) + r + "px", this.style.top = i.y - (s.y - e.y) + n + "px", (e = this.getBoundingClientRect()).left < 7 && (this.style.left = 7 + r + "px", e = this.getBoundingClientRect()), 0 < 7 - e.top && (this.style.height = e.bottom - 7 + "px", this.style.top = 7 + n + "px", this.scrollTop = 9999, e = this.getBoundingClientRect()), e.bottom + 7 > window.innerHeight && (a = e.bottom - window.innerHeight, a = e.height - a - 7, this.style.height = a + "px"), e.right + 7 > window.innerWidth && (a = e.right - window.innerWidth, a = e.width - a - 7, this.style.width = a + "px"); var a = getComputedStyle(this).getPropertyValue("--open-transition"), [a, o, l] = ii(a); "transform" === a && (a = this.getBoundingClientRect(), a = i.y + i.height / 2 - a.top, await this.animate({ transform: ["scaleY(0)", "scaleY(1)"], transformOrigin: [`0 ${a}px`, `0 ${a}px`] }, { duration: o, easing: l }).finished), this.dispatchEvent(new CustomEvent("open", { bubbles: !0, detail: this })), this.#xe = n } t() }) } openOverLabel(i) { return new Promise(async t => { var e = this.querySelectorAll(":scope > x-menuitem"); if (0 < e.length) { this.#Le(), this.setAttribute("opened", ""), this.#we = !0, this.#ye = Ee(); let t = [...e].find(t => { t = t.querySelector("x-label"); return !(!t || t.textContent !== i.textContent) }); e = (t = t || e[0]).querySelector("x-label"); await this.openOverElement(i, e) } t() }) } openNextToElement(h, d = "horizontal", u = 0) { return new Promise(async t => { this.#we = !1, this.#ye = Ee(), this.#Le(), this.setAttribute("opened", ""), this.dispatchEvent(new CustomEvent("open", { bubbles: !0, detail: this })), "x-menuitem" === h.localName && h.setAttribute("expanded", ""); let e = getComputedStyle(this).getPropertyValue("--align").trim(), i = h.getBoundingClientRect(), s = this.getBoundingClientRect(), r = 0, n = 0; if (0 === s.top && 0 === s.left || (r = -s.left, n = -s.top), "horizontal" === d) { this.style.top = i.top + n + "px", this.style.left = i.left + i.width + u + r + "px"; let t = "right"; var a = this.getBoundingClientRect(), a = (a.width > window.innerWidth - 10 && (this.style.width = window.innerWidth - 10 + "px"), a.height > window.innerHeight - 10 && (this.style.height = window.innerHeight - 10 + "px"), this.getBoundingClientRect()), a = (a.left + a.width + 7 > window.innerWidth && (t = i.left > a.width + 7 ? (this.style.left = i.left - a.width + r + "px", "left") : i.left > window.innerWidth - (i.left + i.width) ? (this.style.left = 7 + r + "px", "left") : (this.style.left = window.innerWidth - a.width - 7 + r + "px", "right")), this.getBoundingClientRect()), a = (a.top + a.height + 7 > window.innerHeight && (o = a.top + a.height + 7 - window.innerHeight, this.style.top = a.top - o + n + "px"), getComputedStyle(this).getPropertyValue("--open-transition")), [o, a, l] = ii(a); "transform" === o && await this.animate({ transform: ["scale(0, 0)", "scale(1, 1)"], transformOrigin: ["left" === t ? "100% 0" : "0 0", "left" === t ? "100% 0" : "0 0"] }, { duration: a, easing: l }).finished } else if ("vertical" === d) { this.style.top = i.top + i.height + u + n + "px", this.style.left = "0px"; let t = "bottom"; var o = this.getBoundingClientRect(), l = (o.width > window.innerWidth - 10 && (this.style.width = window.innerWidth - 10 + "px"), o.height > window.innerHeight - 10 && (this.style.height = window.innerHeight - 10 + "px"), h.parentElement && "x-menubar" === h.parentElement.localName ? (a = this.getBoundingClientRect()).top + a.height + 7 > window.innerHeight && (this.style.height = window.innerHeight - (i.top + i.height) - 10 + "px") : (l = this.getBoundingClientRect()).top + l.height + 7 > window.innerHeight && (t = i.top > l.height + 7 ? (this.style.top = i.top - l.height - u + n + "px", "top") : i.top > window.innerHeight - (i.top + i.height) ? (this.style.top = 7 + n + "px", "top") : (this.style.top = window.innerHeight - l.height - 7 + n + "px", "bottom")), "start" === e ? (this.style.left = i.left + r + "px", (o = this.getBoundingClientRect()).left + o.width + 7 > window.innerWidth && (this.style.left = i.left + i.width - o.width + r + "px"), this.getBoundingClientRect().left < 7 && (this.style.left = 7 + r + "px")) : "end" === e && (this.style.left = i.left + i.width - s.width + r + "px", this.getBoundingClientRect().left < 7 && (this.style.left = i.left + r + "px"), (a = this.getBoundingClientRect()).left + a.width + 7 > window.innerWidth && (this.style.left = window.innerWidth - 7 + r + "px")), getComputedStyle(this).getPropertyValue("--open-transition")), [o, a, l] = ii(l); "transform" === o && await this.animate({ transform: ["scale(1, 0)", "scale(1, 1)"], transformOrigin: ["top" === t ? "0 100%" : "0 0", "top" === t ? "0 100%" : "0 0"] }, { duration: a, easing: l }).finished } this.#xe = n, t() }) } openAtPoint(a, o) { return new Promise(async t => { this.#we = !1, this.#ye = Ee(), this.#Le(), this.setAttribute("opened", ""), this.dispatchEvent(new CustomEvent("open", { bubbles: !0, detail: this })); let e = 0, i = 0, s = [...this.querySelectorAll(":scope > x-menuitem > x-label > x-message")], r = (await Promise.all(s.map(t => t.whenReady)), this.getBoundingClientRect()); 0 === r.top && 0 === r.left || (e = -r.left, i = -r.top), this.style.left = a + e + "px", this.style.top = o + i + "px", (r = this.getBoundingClientRect()).right + 7 > window.innerWidth && (a -= r.width, this.style.left = a + e + "px", r = this.getBoundingClientRect()), r.bottom + 7 > window.innerHeight && (o = o + window.innerHeight - (r.top + r.height) - 7, this.style.top = o + i + "px", (r = this.getBoundingClientRect()).top < 7 && (o = 7, this.style.top = o + i + "px", this.style.height = window.innerHeight - 7 - 7 + "px")); var n = getComputedStyle(this).getPropertyValue("--open-transition"), [n] = ii(n); "transform" === n && await this.animate({ transform: ["scale(0)", "scale(1)"], transformOrigin: ["0 0", "0 0"] }, { duration: 80, easing: "cubic-bezier(0.4, 0.0, 0.2, 1)" }).finished, this.#xe = i, t() }) } close(n = !0) { return new Promise(async t => { if (this.opened) { this.removeAttribute("opened"), this.dispatchEvent(new CustomEvent("close", { bubbles: !0, detail: this })); let t = this.closest("x-menuitem"); var e, i, s, r; t && t.removeAttribute("expanded"), n && (this.setAttribute("animating", ""), e = getComputedStyle(this).getPropertyValue("--close-transition"), [e, i, s] = ii(e), "opacity" === e && await this.animate({ opacity: ["1", "0"] }, { duration: i, easing: s }).finished, this.removeAttribute("animating")); for (r of this.querySelectorAll(":scope > x-menuitem")) { let t = r.querySelector("x-menu[opened]"); t && t.close() } } t() }) } focusNextMenuItem() { let i = this.querySelector(":scope > x-menuitem:focus, :scope > x-menuitem[expanded]"); if (i) { let e = null; for (let t = i.nextElementSibling; t; t = t.nextElementSibling)if ("x-menuitem" === t.localName && !1 === t.disabled && !1 === t.hidden) { e = t; break } if (null === e && null != i.parentElement) for (var t of i.parentElement.children) if ("x-menuitem" === t.localName && !1 === t.disabled && !1 === t.hidden) { e = t; break } if (e) { e.focus(); let t = i.querySelector("x-menu"); t && t.close() } } else this.focusFirstMenuItem() } focusPreviousMenuItem() { let i = this.querySelector(":scope > x-menuitem:focus, :scope > x-menuitem[expanded]"); if (i) { let e = null; for (let t = i.previousElementSibling; t; t = t.previousElementSibling)if ("x-menuitem" === t.localName && !1 === t.disabled && !1 === t.hidden) { e = t; break } if (null === e && null != i.parentElement) for (var t of [...i.parentElement.children].reverse()) if ("x-menuitem" === t.localName && !1 === t.disabled && !1 === t.hidden) { e = t; break } if (e) { e.focus(); let t = i.querySelector("x-menu"); t && t.close() } } else this.focusLastMenuItem() } focusFirstMenuItem() { let t = this.querySelectorAll("x-menuitem:not([disabled]):not([hidden])")[0] || null; t && t.focus() } focusLastMenuItem() { let t = this.querySelectorAll("x-menuitem:not([disabled]):not([hidden])"), e = 0 < t.length ? t[t.length - 1] : null; e && e.focus() } #Me(t) { let l = 0; { let a = this.#me[this.#me.length - 1], o = this.#me[0]; if (this.querySelector("x-menu[opened]") && a) { o = o || a; let t = this.getBoundingClientRect(), e = { x: t.left, y: t.top - 75 }, i = { x: t.left + t.width, y: e.y }, s = { x: t.left, y: t.top + t.height + 75 }, r = { x: t.left + t.width, y: s.y }, n = !0; var h, d, u, c; (o.x < t.left || o.x > r.x || o.y < t.top || o.y > r.y) && (n = !1), (n = (!this.#be || a.x !== this.#be.x || a.y !== this.#be.y) && n) && (h = (c = (t, e) => (e.y - t.y) / (e.x - t.x))(a, i), d = c(a, r), u = c(o, i), c = c(o, r), h < u && c < d ? (this.#be = a, l = 300) : this.#be = null) } } 0 < l ? this.#ge = setTimeout(() => { this.#Me(t) }, l) : t() } #Te() { this.#ge && (clearTimeout(this.#ge), this.#ge = null) } #Le() { this.style.position = "fixed", this.style.top = "0px", this.style.left = "0px", this.style.width = null, this.style.height = null, this.style.minWidth = null, this.style.maxWidth = null } #$e() { return this.matches("*[closing], *[closing] x-menu") } #Ae() { this.setAttribute("aria-hidden", !this.opened) } #pt(t) { if (t.target !== this && "hr" !== t.target.localName || t.stopPropagation(), "touch" === t.pointerType && t.target.closest("x-menu") === this) { !1 === this.#ve && this.#De(); { let r = t.target.closest("x-menuitem"); r && !1 === r.disabled && r.closest("x-menu") === this ? !1 === r.matches(":focus") && this.#Me(async () => { let e = this.querySelector(":scope > x-menuitem:focus"); if (e) { let t = e.querySelector("x-menu"); t && t.close() } r.closest("x-menu"); let t = r.querySelector("x-menu"), i = [...this.querySelectorAll(":scope > x-menuitem")].filter(t => t !== r); t && (await Se(60), r.matches(":focus") && !1 === t.opened && t.openNextToElement(r, "horizontal")); for (var s of i) { let t = s.querySelector("x-menu"); t && t.close() } }) : this.#Me(() => { this.focus() }) } } } #ke(t) { if (!this.#$e() && "touch" !== t.pointerType && t.target.closest("x-menu") === this) { !1 === this.#ve && this.#De(); { let r = t.target.closest("x-menuitem"); r && !1 === r.disabled && r.closest("x-menu") === this ? !1 === r.matches(":focus") && this.#Me(async () => { let e = this.querySelector(":scope > x-menuitem:focus"); if (e) { let t = e.querySelector("x-menu"); t && t.close() } r.focus(), r.closest("x-menu"); let t = r.querySelector("x-menu"), i = [...this.querySelectorAll(":scope > x-menuitem")].filter(t => t !== r); t && (await Se(60), r.matches(":focus") && !1 === t.opened && t.openNextToElement(r, "horizontal")); for (var s of i) { let t = s.querySelector("x-menu"); t && t.close() } }) : this.#Me(() => { this.focus() }) } } } #ze(t) { t.relatedTarget && Ne(t.relatedTarget, "x-menu") === this || !0 === this.#ve && this.#Re() } #De() { this.#$e() || (this.#ve = !0, this.#Te()) } #Re() { this.#$e() || (this.#ve = !1, this.#Te(), this.focus()) } #Ce(t) { this.#me.push({ x: t.clientX, y: t.clientY }), 3 < this.#me.length && this.#me.shift() } #Se(t) { t.target.closest("x-menu") === this ? (t.preventDefault(), this.scrollTop = this.scrollTop + t.deltaY, this.#ve = !0) : this.#ve = !1 } #Ee() { var t, e; this.#we && (t = this.scrollTop - this.#fe, this.#fe = this.scrollTop, 100 < Ee() - this.#ye && (e = this.getBoundingClientRect(), t < 0 ? e.bottom + si(t) <= window.innerHeight - 7 ? this.style.height = e.height + si(t) + "px" : this.style.height = window.innerHeight - 14 + "px" : 0 < t && (7 <= e.top - t ? (this.style.top = this.#xe + e.top - t + "px", this.style.height = e.height + t + "px", this.scrollTop = 0, this.#fe = 0) : (this.style.top = 7 + this.#xe + "px", this.style.height = window.innerHeight - 14 + "px")))) } #bt(s) { if (this.#$e()) s.preventDefault(), s.stopPropagation(); else if ("ArrowUp" === s.key) s.preventDefault(), s.stopPropagation(), this.focusPreviousMenuItem(); else if ("ArrowDown" === s.key) s.preventDefault(), s.stopPropagation(), this.focusNextMenuItem(); else if ("ArrowRight" === s.code || "Enter" === s.code || "Space" === s.code) { let i = this.querySelector("x-menuitem:focus"); if (i) { let e = i.querySelector("x-menu"); if (e) { s.preventDefault(), s.stopPropagation(), !1 === e.opened && e.openNextToElement(i, "horizontal"); let t = e.querySelector("x-menuitem:not([disabled]):not([hidden])"); t && t.focus() } } } else if ("ArrowLeft" === s.code) { let e = this.querySelector("x-menuitem:focus"); if (e) { let t = e.closest("x-menu").closest("x-menuitem"); t && t.closest("x-menu") && (s.preventDefault(), s.stopPropagation(), t.focus(), this.close()) } } } } customElements.define("x-menu", ni); class oi extends HTMLElement {
    static observedAttributes = ["disabled", "size"]; static #A = Mt`<template><svg id="backdrop" hidden><path id="backdrop-path"></path></svg><slot></slot></template>`; static #L = Tt`:host{display:flex;align-items:center;width:100%;height:36px;box-sizing:border-box}:host([disabled]){pointer-events:none;opacity:.6}:host([hidden]){display:none}#backdrop{position:fixed;top:0;left:0;width:100%;height:100%;z-index:1000;pointer-events:none;touch-action:none}#backdrop[hidden]{display:none}#backdrop path{fill:red;fill-rule:evenodd;opacity:0;pointer-events:all}`; get disabled() { return this.hasAttribute("disabled") } set disabled(t) { t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled") } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } #T = null; #M = {}; #Pe = !1; #D = null; #Ie = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [oi.#L], this.#T.append(document.importNode(oi.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t; this.addEventListener("focusout", t => this.#ee(t)), this.#T.addEventListener("pointerover", t => this.#Oe(t)), this.#T.addEventListener("click", t => this.#Fe(t)), this.#T.addEventListener("wheel", t => this.#Be(t)), this.#T.addEventListener("keydown", t => this.#Ne(t)) } connectedCallback() { this.setAttribute("role", "menubar"), this.setAttribute("aria-disabled", this.disabled), this.#F(), Me.addEventListener("sizechange", this.#D = () => { this.#F() }), window.addEventListener("orientationchange", this.#Ie = () => { this.#je() }) } disconnectedCallback() { Me.removeEventListener("sizechange", this.#D), window.removeEventListener("orientationchange", this.#Ie) } attributeChangedCallback(t) { "disabled" === t ? this.#Ot() : "size" === t && this.#F() } #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } #He(t) {
        let e = t.querySelector(":scope > x-menu"); if (e && !1 === e.opened) {
            var i; t.focus(), this.#Pe = !0, this.style.touchAction = "none", e.openNextToElement(t, "vertical"); for (i of [...this.querySelectorAll(":scope > x-menuitem > x-menu")].filter(t => t !== e)) i && i.close(!1); var { x: t, y: s, width: r, height: n } = this.getBoundingClientRect(); this.#M["backdrop-path"].setAttribute("d", `
          M 0 0
          L ${window.innerWidth} 0
          L ${window.innerWidth} ${window.innerHeight}
          L 0 ${window.innerHeight}
          L 0 0
          M ${t} ${s}
          L ${t + r} ${s}
          L ${t + r} ${s + n}
          L ${t} ${s + n}
        `), this.#M.backdrop.removeAttribute("hidden")
        }
    } #Ue() { return new Promise(async t => { var e; this.#Pe = !1, this.style.touchAction = null, this.#M.backdrop.setAttribute("hidden", ""), this.#M["backdrop-path"].setAttribute("d", ""); for (e of this.querySelectorAll(":scope > x-menuitem > x-menu[opened]")) await e.close(!0); let i = this.querySelector("x-menuitem:focus"); i && i.blur(), t() }) } #qe() { let t = [...this.querySelectorAll(":scope > x-menuitem:not([disabled])")], e = this.querySelector(":focus").closest("x-menubar > x-menuitem"); var i; 1 < t.length && e && (i = t.indexOf(e), i = t[i - 1] || t[t.length - 1], this.#He(i)) } #Ke() { let t = [...this.querySelectorAll(":scope > x-menuitem:not([disabled])")], e = this.querySelector(":focus").closest("x-menubar > x-menuitem"); var i; e && 1 < t.length && (i = t.indexOf(e), i = t[i + 1] || t[0], this.#He(i)) } #Ot() { this.setAttribute("aria-disabled", this.disabled) } #ee(t) { null !== t.relatedTarget && !1 !== this.contains(t.relatedTarget) || this.#Ue() } #je() { this.#Ue() } #Be(t) { let e = this.querySelector("x-menu[opened]"); e && !1 === e.contains(t.target) && t.preventDefault() } async#Fe(i) { if (!this.hasAttribute("closing")) { let e = i.target.closest("x-menuitem"), t = i.target.closest("x-menu"); if (!e || !1 !== e.disabled || t && !t.contains(e)) i.target === this.#M["backdrop-path"] && (this.#Ue(), i.preventDefault(), i.stopPropagation()); else { let t = e.querySelector("x-menu"); e.parentElement === this ? t && (t.opened ? this.#Ue() : this.#He(e)) : t ? t.opened && !1 === t.opened && t.openNextToElement(e, "horizontal") : (this.setAttribute("closing", ""), await e.whenTriggerEnd, await this.#Ue(), this.removeAttribute("closing")) } } } #Oe(e) { if (!this.hasAttribute("closing")) { let t = e.target.closest("x-menuitem"); null === e.target.closest("x-menu") && t && t.parentElement === this && this.#Pe && "touch" !== e.pointerType && (!1 === t.hasAttribute("expanded") ? this.#He(t) : t.focus()) } } #Ne(e) { if (this.hasAttribute("closing")) e.stopPropagation(), e.preventDefault(); else if ("Enter" === e.code || "Space" === e.code) { let t = this.querySelector(":scope > x-menuitem:focus"); t && (e.preventDefault(), t.click()) } else if ("Escape" === e.code) this.#Pe && (e.preventDefault(), this.#Ue()); else if ("Tab" === e.code) { let e = this.querySelector(":scope > x-menuitem:focus, :scope > x-menuitem[expanded]"); if (e) { e.focus(); let t = e.querySelector(":scope > x-menu"); t && (t.tabIndex = -1, t.close().then(() => { t.tabIndex = -1 })) } } else if ("ArrowRight" === e.code) this.#Ke(); else if ("ArrowLeft" === e.code) this.#qe(); else if ("ArrowDown" === e.code) { let t = this.querySelector("x-menuitem:focus > x-menu"); t && (e.preventDefault(), t.focusFirstMenuItem()) } else if ("ArrowUp" === e.code) { let t = this.querySelector("x-menuitem:focus > x-menu"); t && (e.preventDefault(), t.focusLastMenuItem()) } }
} customElements.define("x-menubar", oi); let ri = Math["max"]; class hi extends HTMLElement { static observedAttributes = ["disabled", "size"]; static #A = Mt`<template><div id="ripples"></div><svg id="checkmark" part="checkmark" viewBox="0 0 100 100" preserveAspectRatio="none"><path></path></svg><slot></slot><svg id="arrow" part="arrow" viewBox="0 0 100 100" hidden><path></path></svg></template>`; static #L = Tt`:host{display:flex;flex-flow:row;align-items:center;position:relative;padding:0 12px 0 23px;min-height:28px;box-sizing:border-box;cursor:default;user-select:none;--trigger-effect:blink}:host([hidden]){display:none}:host([disabled]){pointer-events:none;opacity:.6}:host(:focus){outline:0}:host-context([debug]):host(:focus){outline:2px solid red}#ripples{position:absolute;z-index:0;top:0;left:0;width:100%;height:100%;pointer-events:none;contain:strict;overflow:hidden}#ripples .ripple{position:absolute;top:0;left:0;width:200px;height:200px;background:currentColor;opacity:.1;border-radius:999px;transform:none;transition:all .8s cubic-bezier(.4, 0, .2, 1);will-change:opacity,transform;pointer-events:none}#checkmark{display:none;transition:transform .2s cubic-bezier(.4, 0, .2, 1);align-self:center;width:18px;height:18px;margin:0 2px 0 -20px;d:path("M 44 61 L 29 47 L 21 55 L 46 79 L 79 27 L 70 21 L 44 61 Z");color:inherit}:host([togglable]) #checkmark{display:flex;transform:scale(0);transform-origin:50% 50%}:host([toggled]) #checkmark{display:flex;transform:scale(1)}#checkmark path{d:inherit;fill:currentColor}#arrow{display:flex;width:16px;height:16px;transform:scale(1.1);align-self:center;margin-left:8px;d:path("M 26 20 L 26 80 L 74 50 Z");opacity:1;color:inherit}#arrow[hidden]{display:none}#arrow path{d:inherit;fill:currentColor}`; get value() { return this.hasAttribute("value") ? this.getAttribute("value") : null } set value(t) { this.value !== t && (null === t ? this.removeAttribute("value") : this.setAttribute("value", t)) } get toggled() { return this.hasAttribute("toggled") } set toggled(t) { t ? this.setAttribute("toggled", "") : this.removeAttribute("toggled") } get togglable() { return this.hasAttribute("togglable") } set togglable(t) { t ? this.setAttribute("togglable", "") : this.removeAttribute("togglable") } get disabled() { return this.hasAttribute("disabled") } set disabled(t) { t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled") } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } get whenTriggerEnd() { return new Promise(t => { 0 === this.#M.ripples.childElementCount && !1 === this.#Ve ? t() : this.#Xe.push(t) }) } #T = null; #M = {}; #ct = 0; #Ve = !1; #Xe = []; #Ze = !1; #D = null; #Ge = new MutationObserver(() => this.#We()); constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [hi.#L], this.#T.append(document.importNode(hi.#A.content, !0)), this.addEventListener("pointerdown", t => this.#pt(t)), this.addEventListener("click", t => this.#I(t)), this.addEventListener("keydown", t => this.#bt(t)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t } connectedCallback() { this.#We(), this.#xt(), this.#F(), this.#Ge.observe(this, { childList: !0, attributes: !1, characterData: !1, subtree: !1 }), Me.addEventListener("sizechange", this.#D = () => this.#F()) } disconnectedCallback() { this.#Ge.disconnect(), Me.removeEventListener("sizechange", this.#D) } attributeChangedCallback(t) { "disabled" === t ? this.#xt() : "size" === t && this.#F() } #We() { "x-menubar" !== this.parentElement.localName && this.querySelector("x-menu") ? this.#M.arrow.removeAttribute("hidden") : this.#M.arrow.setAttribute("hidden", "") } #xt() { this.setAttribute("role", "menuitem"), this.setAttribute("aria-disabled", this.disabled), this.disabled ? (this.#ct = 0 < this.tabIndex ? this.tabIndex : 0, this.tabIndex = -1) : (this.tabIndex < 0 && (this.tabIndex = 0 < this.#ct ? this.#ct : 0), this.#ct = 0) } #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } async#pt(a) { if (this.#Ze = this.matches(":focus"), 1 < a.buttons) return !1; if (this.matches("[closing] x-menuitem")) return a.preventDefault(), void a.stopPropagation(); if (a.target.closest("x-menuitem") === this) { this.setPointerCapture(a.pointerId); { let i = Date.now(), s = !0; this.addEventListener("pointerup", async () => { s = !1; var t = Date.now() - i, e = "touch" === a.pointerType ? 600 : 150; t < e && await Se(e - t), this.removeAttribute("pressed") }, { once: !0 }), s && this.setAttribute("pressed", "") } if ("ripple" === getComputedStyle(this).getPropertyValue("--trigger-effect").trim()) { let t = this.#M.ripples.getBoundingClientRect(), e = 1.5 * ri(t.width, t.height), i = a.clientY - t.y - e / 2, s = a.clientX - t.x - e / 2, r = new Promise(t => this.addEventListener("pointerup", t, { once: !0 })), n = Be("div"); n.setAttribute("part", "ripple"), n.setAttribute("class", "ripple pointer-down-ripple"), n.setAttribute("style", `width: ${e}px; height: ${e}px; top: ${i}px; left: ${s}px;`), this.#M.ripples.append(n), this.setPointerCapture(a.pointerId); var o = n.animate({ transform: ["scale3d(0, 0, 0)", "none"] }, { duration: 300, easing: "cubic-bezier(0.4, 0, 0.2, 1)" }), o = (await r, await o.finished, n.animate({ opacity: [getComputedStyle(n).opacity, "0"] }, { duration: 300, easing: "cubic-bezier(0.4, 0, 0.2, 1)" })); if (await o.finished, n.remove(), 0 === this.#M.ripples.childElementCount) for (var l of this.#Xe) l() } } } async#I(t) { if (!(1 < t.buttons || t.target.closest("x-menuitem") !== this || t.target.closest("x-menu") !== this.closest("x-menu") || this.matches("[closing] x-menuitem")) && (this.togglable && (t = new CustomEvent("toggle", { bubbles: !0, cancelable: !0 }), this.dispatchEvent(t), !1 === t.defaultPrevented && (this.toggled = !this.toggled)), !this.querySelector(":scope > x-menu"))) { t = getComputedStyle(this).getPropertyValue("--trigger-effect").trim(); if ("ripple" === t) { if (null === this.#M.ripples.querySelector(".pointer-down-ripple")) { let t = this.#M.ripples.getBoundingClientRect(), e = 1.5 * ri(t.width, t.height), i = t.y + t.height / 2 - t.y - e / 2, s = t.x + t.width / 2 - t.x - e / 2, r = Be("div"); r.setAttribute("part", "ripple"), r.setAttribute("class", "ripple click-ripple"), r.setAttribute("style", `width: ${e}px; height: ${e}px; top: ${i}px; left: ${s}px;`), this.#M.ripples.append(r); await r.animate({ transform: ["scale3d(0, 0, 0)", "none"] }, { duration: 300, easing: "cubic-bezier(0.4, 0, 0.2, 1)" }).finished; var n = r.animate({ opacity: [getComputedStyle(r).opacity, "0"] }, { duration: 300, easing: "cubic-bezier(0.4, 0, 0.2, 1)" }); if (await n.finished, r.remove(), 0 === this.#M.ripples.childElementCount) { for (var a of this.#Xe) a(); this.#Xe = [] } } } else if ("blink" === t) { this.#Ve = !0, this.#Ze ? (this.parentElement.focus(), await Se(150), this.focus()) : (this.focus(), await Se(150), this.parentElement.focus()), await Se(150); for (var e of this.#Xe) e(); this.#Xe = [], this.#Ve = !1 } else if ("none" === t) { this.#Ve = !0, await Se(50); for (var i of this.#Xe) i(); this.#Xe = [], this.#Ve = !1 } } } #bt(t) { "Enter" !== t.code && "Space" !== t.code || (t.preventDefault(), this.querySelector("x-menu") || (t.stopPropagation(), this.click())) } } customElements.define("x-menuitem", hi); class ai extends HTMLElement { static observedAttributes = ["opened", "size"]; static #A = Mt`<template><slot></slot></template>`; static #L = Tt`:host{display:none;position:fixed;min-width:15px;min-height:15px;bottom:15px;left:50%;transform:translateX(-50%);padding:5px 12px;box-sizing:border-box;color:rgba(255,255,255,.9);background:#434343;z-index:9999;font-size:12px;user-select:text;transition:transform .15s cubic-bezier(.4, 0, .2, 1)}:host([animating]),:host([opened]){display:block}:host(:focus){outline:0}`; get opened() { return this.hasAttribute("opened") } set opened(t) { !0 === t ? this.setAttribute("opened", "") : this.removeAttribute("opened"), this.#Ye = 0 } get timeout() { return this.hasAttribute("timeout") ? parseFloat(this.getAttribute("timeout")) : 0 } set timeout(t) { this.setAttribute("timeout", t) } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } #T = null; #Ye = 0; #_e = null; #D = null; #Je = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [ai.#L], this.#T.append(document.importNode(ai.#A.content, !0)) } connectedCallback() { this.setAttribute("tabindex", "0"), this.#F(), Me.addEventListener("sizechange", this.#D = () => this.#F()) } disconnectedCallback() { Me.removeEventListener("sizechange", this.#D) } attributeChangedCallback(t, e, i) { e !== i && ("opened" === t ? this.opened ? this.#Qe() : this.#ti() : "size" === t && this.#F()) } #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } #Qe() { var t, e; this.isConnected && (t = 0 - this.getBoundingClientRect().height - 10 + "px", e = getComputedStyle(this).bottom, this.animate({ bottom: [t, e] }, { duration: 300, easing: "cubic-bezier(0.4, 0, 0.2, 1)" })); { this.#Ye = 0, this.#_e = setInterval(() => { this.#Ye += 100, 0 < this.timeout && this.#Ye > this.timeout && (this.opened = !1) }, 100); let s = Ee(); window.addEventListener("pointerdown", this.#Je = t => { var e = Ee(), i = this.getBoundingClientRect(); 10 < e - s && 0 == (e = i, (i = new DOMPoint(t.clientX, t.clientY)).x >= e.x && i.x <= e.x + e.width && i.y >= e.y && i.y <= e.y + e.height) && (this.opened = !1) }, !0) } } async#ti() { var t, e; clearInterval(this.#_e), this.isConnected && (this.setAttribute("animating", ""), t = getComputedStyle(this).bottom, e = 0 - this.getBoundingClientRect().height - 10 + "px", await this.animate({ bottom: [t, e] }, { duration: 300, easing: "cubic-bezier(0.4, 0, 0.2, 1)" }).finished, this.removeAttribute("animating")), window.removeEventListener("pointerdown", this.#Je, !0) } } customElements.define("x-notification", ai); let li = Number["isFinite"]; const di = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-", "+", ",", "."]; class ui extends HTMLElement { static observedAttributes = ["value", "min", "max", "prefix", "suffix", "disabled", "size"]; static #A = Mt`<template><main id="main"><div id="editor-container"><div id="editor" contenteditable="plaintext-only" spellcheck="false"></div></div><slot></slot></main></template>`; static #L = Tt`:host{display:block;position:relative;max-width:160px;height:32px;box-sizing:border-box;font-size:12.5px}:host(:hover){cursor:text}:host([mixed]){color:rgba(0,0,0,.7)}:host([disabled]){pointer-events:none;opacity:.5}:host([hidden]){display:none}::selection{color:var(--selection-color);background-color:var(--selection-background-color)}#main{display:flex;align-items:center;height:100%}#editor-container{display:flex;align-items:center;width:100%;height:100%;padding:0 6px;box-sizing:border-box;overflow:hidden}#editor{width:100%;overflow:auto;color:inherit;background:0 0;border:none;outline:0;font-family:inherit;font-size:inherit;line-height:10;white-space:nowrap}#editor::-webkit-scrollbar{display:none}#editor::before{content:attr(data-prefix);pointer-events:none}#editor::after{content:attr(data-suffix);pointer-events:none}:host(:focus) #editor::after,:host(:focus) #editor::before,:host([empty]) #editor::after,:host([empty]) #editor::before{content:""}`; get value() { return this.hasAttribute("value") ? parseFloat(this.getAttribute("value")) : null } set value(t) { null === t ? this.removeAttribute("value") : this.setAttribute("value", t) } get min() { return this.hasAttribute("min") ? parseFloat(this.getAttribute("min")) : -1 / 0 } set min(t) { li(t) ? this.setAttribute("min", t) : this.removeAttribute("min") } get max() { return this.hasAttribute("max") ? parseFloat(this.getAttribute("max")) : 1 / 0 } set max(t) { li(t) ? this.setAttribute("max", t) : this.removeAttribute("max") } get mixed() { return this.hasAttribute("mixed") } set mixed(t) { t ? this.setAttribute("mixed", "") : this.removeAttribute("mixed") } get precision() { return this.hasAttribute("precision") ? parseFloat(this.getAttribute("precision")) : 20 } set precision(t) { this.setAttribute("precision", t) } get step() { return this.hasAttribute("step") ? parseFloat(this.getAttribute("step")) : 1 } set step(t) { this.setAttribute("step", t) } get prefix() { return this.hasAttribute("prefix") ? this.getAttribute("prefix") : "" } set prefix(t) { this.setAttribute("prefix", t) } get suffix() { return this.hasAttribute("suffix") ? this.getAttribute("suffix") : "" } set suffix(t) { this.setAttribute("suffix", t) } get mixed() { return this.hasAttribute("mixed") } set mixed(t) { t ? this.setAttribute("mixed", "") : this.removeAttribute("mixed") } get disabled() { return this.hasAttribute("disabled") } set disabled(t) { t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled") } get condensed() { return this.hasAttribute("condensed") } set condensed(t) { t ? this.setAttribute("condensed", "") : this.removeAttribute("condensed") } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } #T = null; #M = {}; #ct = 0; #D = null; #ei = !1; #ii = !1; #si = !1; #ni = !1; #oi = !1; constructor() { super(), this.#T = this.attachShadow({ mode: "closed", delegatesFocus: !0 }), this.#T.adoptedStyleSheets = [ui.#L], this.#T.append(document.importNode(ui.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t; this.#T.addEventListener("pointerdown", t => this.#ri(t)), this.#T.addEventListener("wheel", t => this.#Se(t)), this.#M.editor.addEventListener("paste", t => this.#hi(t)), this.#M.editor.addEventListener("input", t => this.#ai(t)), this.addEventListener("pointerdown", t => this.#pt(t)), this.addEventListener("pointerenter", () => this.#mt()), this.addEventListener("pointerleave", () => this.#gt()), this.addEventListener("keydown", t => this.#bt(t)), this.addEventListener("keyup", t => this.#li(t)), this.addEventListener("keypress", t => this.#di(t)), this.addEventListener("incrementstart", t => this.#ui(t)), this.addEventListener("decrementstart", t => this.#ci(t)), this.addEventListener("focusin", t => this.#te(t)), this.addEventListener("focusout", t => this.#ee(t)) } connectedCallback() { this.#xt(), this.#F(), this.#J(), Me.addEventListener("sizechange", this.#D = () => this.#F()) } disconnectedCallback() { Me.removeEventListener("sizechange", this.#D) } attributeChangedCallback(t) { "value" === t ? this.#Q() : "min" === t ? this.#pi() : "max" === t ? this.#mi() : "prefix" === t ? this.#gi() : "suffix" === t ? this.#bi() : "disabled" === t ? this.#Ot() : "size" === t && this.#tt() } #fi(t = !1) { var e = this.value, i = this.value; i += t ? 10 * this.step : this.step, e !== (i = h(i, this.min, this.max, a(this.step))) && (this.value = i), this.matches(":focus") && document.execCommand("selectAll"), this.#xi() } #wi(t = !1) { var e = this.value, i = this.value; i -= t ? 10 * this.step : this.step, e !== (i = h(i, this.min, this.max, a(this.step))) && (this.value = i), this.matches(":focus") && document.execCommand("selectAll"), this.#xi() } #vi() { this.#ii || (this.#ii = !0, this.dispatchEvent(new CustomEvent("changestart", { bubbles: !0 }))) } #yi = Le(() => { !this.#ii || this.#si || this.#ni || this.#oi || (this.#ii = !1, this.dispatchEvent(new CustomEvent("changeend", { bubbles: !0 }))) }, 500); #ki() { let t = this.#M.editor.textContent, e = "" === t.trim() ? null : parseFloat(t), i = null === e ? null : h(e, this.min, this.max); i !== this.value ? (this.dispatchEvent(new CustomEvent("changestart", { bubbles: !0 })), this.value = i, this.dispatchEvent(new CustomEvent("change", { bubbles: !0 })), this.dispatchEvent(new CustomEvent("changeend", { bubbles: !0 }))) : e !== this.value && (this.value = i) } #J() { this.#zi(), this.#xi(), this.#Ci() } #zi() { this.hasAttribute("value") ? this.#M.editor.textContent = this.getAttribute("value").trim() : this.#M.editor.textContent = "" } #xi() { let e = null; if (this.matches(":focus")) { let t = this.#M.editor.textContent; e = "" === t.trim() ? null : parseFloat(t) } else e = this.value; null === e ? this.setAttribute("empty", "") : this.removeAttribute("empty") } #Ci() { let t = this.querySelector("x-stepper"); var e, i; t && (e = this.value > this.min, !0 == (i = this.value < this.max) && !0 == e ? t.removeAttribute("disabled") : !1 == i && !1 == e ? t.setAttribute("disabled", "") : !1 == i ? t.setAttribute("disabled", "increment") : !1 == e && t.setAttribute("disabled", "decrement")) } #xt() { this.setAttribute("role", "input"), this.setAttribute("aria-disabled", this.disabled), this.disabled ? (this.#ct = 0 < this.tabIndex ? this.tabIndex : 0, this.tabIndex = -1) : (this.tabIndex < 0 && (this.tabIndex = 0 < this.#ct ? this.#ct : 0), this.#ct = 0) } #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } #Q() { this.#J() } #pi() { this.#Ci() } #mi() { this.#Ci() } #gi() { this.#M.editor.setAttribute("data-prefix", this.prefix) } #bi() { this.#M.editor.setAttribute("data-suffix", this.suffix) } #Ot() { this.#M.editor.disabled = this.disabled, this.#xt() } #tt() { this.#F() } #te() { document.execCommand("selectAll"), this.dispatchEvent(new CustomEvent("textinputmodestart", { bubbles: !0, composed: !0 })) } #ee() { this.#T.getSelection().collapse(this.#M.main), this.#M.editor.scrollLeft = 0, this.#ki(), this.dispatchEvent(new CustomEvent("textinputmodeend", { bubbles: !0, composed: !0 })) } #ai() { this.#xi(), this.#Ci() } #Se(t) { this.matches(":focus") && (t.preventDefault(), this.#vi(), 0 < t.wheelDeltaX || 0 < t.wheelDeltaY ? this.#fi(t.shiftKey) : this.#wi(t.shiftKey), this.dispatchEvent(new CustomEvent("change", { bubbles: !0 })), this.#yi()) } #I(t) { t.preventDefault() } #pt(t) { "x-stepper" === t.target.localName && t.preventDefault() } #ri(d) { if (1 < d.buttons || !1 === d.isPrimary) d.preventDefault(); else if (d.target === this.#M.editor && !1 === this.#M.editor.matches(":focus")) { d.preventDefault(); let t, e, r = this.value, n = d.clientX, o = new DOMPoint(d.clientX, d.clientY); this.style.cursor = "col-resize", this.#M.editor.setPointerCapture(d.pointerId), this.#M.editor.addEventListener("pointermove", t = t => { var e = new DOMPoint(t.clientX, t.clientY), i = t.timeStamp - d.timeStamp, s = t.clientX !== n, e = 3 < l(o, e) || 80 < i; n = t.clientX, s && e && t.isPrimary && (!1 === this.#ei && (this.#ei = !0, this.#ii = !0, this.dispatchEvent(new CustomEvent("changestart", { bubbles: !0 }))), i = t.clientX - d.clientX, s = r + i * this.step, s = h(s, this.min, this.max, a(this.step)), this.value = s, this.dispatchEvent(new CustomEvent("change", { bubbles: !0 }))) }), this.#M.editor.addEventListener("pointerup", e = () => { this.#M.editor.removeEventListener("pointermove", t), this.#M.editor.removeEventListener("pointerup", e), !(this.style.cursor = null) === this.#ei ? (this.#ei = !1, this.#ii = !1, this.dispatchEvent(new CustomEvent("changeend", { detail: this.value !== r, bubbles: !0 }))) : (this.#M.editor.focus(), document.execCommand("selectAll")) }) } } #mt() { let t = this.querySelector(":scope > x-tooltip"); t && !1 === t.disabled && t.open(this) } #gt() { let t = this.querySelector(":scope > x-tooltip"); t && t.close() } #ui(t) { let e, i; this.matches(":focus") && this.#ki(), this.#oi = !0, this.addEventListener("increment", e = t => { this.#vi(), this.#fi(t.detail.shiftKey), this.dispatchEvent(new CustomEvent("change", { bubbles: !0 })), this.#yi(), this.#J() }), this.addEventListener("incrementend", i = t => { this.#oi = !1, this.removeEventListener("increment", e), this.removeEventListener("incrementend", i) }) } #ci(t) { let e, i; this.matches(":focus") && this.#ki(), this.#oi = !0, this.addEventListener("decrement", e = t => { this.#vi(), this.#wi(t.detail.shiftKey), this.dispatchEvent(new CustomEvent("change", { bubbles: !0 })), this.#yi(), this.#J() }), this.addEventListener("decrementend", i = t => { this.#oi = !1, this.removeEventListener("decrement", e), this.removeEventListener("decrementend", i) }) } #bt(t) { "ArrowDown" === t.code ? (t.preventDefault(), this.#si = !0, this.#vi(), this.#wi(t.shiftKey), this.dispatchEvent(new CustomEvent("change", { bubbles: !0 })), this.#yi(), this.#J()) : "ArrowUp" === t.code ? (t.preventDefault(), this.#si = !0, this.#vi(), this.#fi(t.shiftKey), this.dispatchEvent(new CustomEvent("change", { bubbles: !0 })), this.#yi(), this.#J()) : "Backspace" === t.code ? this.#ni = !0 : "Enter" === t.code && (this.#ki(), document.execCommand("selectAll")) } #li(t) { "ArrowDown" === t.code || "ArrowUp" === t.code ? (this.#si = !1, this.#yi()) : "Backspace" === t.code && (this.#ni = !1) } #di(t) { !1 === di.includes(t.key) && t.preventDefault() } async#hi(t) { t.preventDefault(); t = t.clipboardData.getData("text/plain").trim(); (t => { t = ti(t); return !1 === Qe(t) && Je(t) })(t) && (await Se(1), document.execCommand("insertText", !1, t)) } } customElements.define("x-numberinput", ui); class ci extends HTMLElement { static observedAttributes = ["modal"]; static #A = Mt`<template><svg id="arrow" viewBox="0 0 100 100" preserveAspectRatio="none"><path id="arrow-path"></path></svg><slot id="slot"></slot></template>`; static #L = Tt`:host{position:fixed;display:none;top:0;left:0;min-height:30px;z-index:1001;box-sizing:border-box;background:#fff;-webkit-app-region:no-drag;--align:bottom;--arrow-size:20px;--open-transition:900 transform cubic-bezier(0.4, 0, 0.2, 1);--close-transition:200 opacity cubic-bezier(0.4, 0, 0.2, 1)}:host(:focus){outline:0}:host([animating]),:host([opened]){display:flex}#arrow{position:fixed;box-sizing:border-box;content:""}#arrow[data-align=bottom],#arrow[data-align=top]{width:var(--arrow-size);height:calc(var(--arrow-size) * .6);transform:translate(-50%,0)}#arrow[data-align=left],#arrow[data-align=right]{width:calc(var(--arrow-size) * .6);height:var(--arrow-size);transform:translate(0,-50%)}#arrow path{stroke-width:1;vector-effect:non-scaling-stroke}#arrow[data-align=bottom] path{d:path("M 0 100, L 50 0, L 100 100")}#arrow[data-align=top] path{d:path("M 0 0, L 50 100, L 100 0")}#arrow[data-align=left] path{d:path("M 0 0, L 100 50, L 00 100")}#arrow[data-align=right] path{d:path("M 100 0, L 0 50, L 100 100")}#slot{border-radius:inherit}`; get opened() { return this.hasAttribute("opened") } get modal() { return this.hasAttribute("modal") } set modal(t) { t ? this.setAttribute("modal", "") : this.removeAttribute("modal") } #T = null; #M = {}; #Si = null; #Ei = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [ci.#L], this.#T.append(document.importNode(ci.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t; this.#M.backdrop = Be("x-backdrop"), this.#M.backdrop.style.background = "rgba(0, 0, 0, 0)", (this.#M.backdrop.ownerElement = this).#M.backdrop.addEventListener("click", t => { t.preventDefault() }), this.#M.backdrop.addEventListener("pointerdown", t => { this.hasAttribute("animating") && t.stopPropagation() }) } connectedCallback() { this.tabIndex = -1 } attributeChangedCallback(t, e, i) { e !== i && "modal" === t && (this.modal && this.opened ? this.#M.backdrop.show() : this.#M.backdrop.hide()) } open(r, n = !0) { return new Promise(async t => { var e, i, s; !1 === this.opened && (this.modal && this.#M.backdrop.show(!1), this.setAttribute("opened", ""), this.#Ai(), this.#Li(r), this.#Si = je(this), this.#Si && this.#Si.addEventListener("scroll", this.#Ei = () => { this.close() }, { once: !0 }), n && (e = getComputedStyle(this).getPropertyValue("--open-transition"), [e, i, s] = ii(e), "transform" === e && await this.animate({ transform: ["scale(1, 0)", "scale(1, 1)"], transformOrigin: ["0 0", "0 0"] }, { duration: i, easing: s }).finished), this.dispatchEvent(new CustomEvent("open", { bubbles: !0, detail: this }))), t() }) } close(r = !0) { return new Promise(async t => { var e, i, s; !0 === this.opened && (this.removeAttribute("opened"), this.#M.backdrop.hide(), this.dispatchEvent(new CustomEvent("close", { bubbles: !0, detail: this })), this.#Si.removeEventListener("scroll", this.#Ei), r) && (e = getComputedStyle(this).getPropertyValue("--close-transition"), [e, i, s] = ii(e), this.setAttribute("animating", ""), "opacity" === e && await this.animate({ opacity: ["1", "0"] }, { duration: i, easing: s }).finished, this.removeAttribute("animating")), t() }) } #Li(i) { let t = getComputedStyle(this).getPropertyValue("--align").trim(), n = parseInt(getComputedStyle(this).borderWidth), a = 0, o = 0, l = null; this.style.maxWidth = null, this.style.maxHeight = null, this.style.left = "0px", this.style.top = "0px"; var s = r(this.getBoundingClientRect()); if (0 === s.top && 0 === s.left || (a = -s.left, o = -s.top), l = i instanceof DOMPoint ? new DOMRect(i.x, i.y, 0, 0) : i instanceof DOMRect ? i : i instanceof Element ? i.getBoundingClientRect() : new DOMRect, "bottom" === t || "top" === t) { var s = (t = !1) => { this.style.maxHeight = null, this.#M.arrow.setAttribute("data-align", "bottom"); r(this.getBoundingClientRect()); let e, i = r(this.#M.arrow.getBoundingClientRect()), s = 0; return this.#M.arrow.style.top = o + l.bottom + 2 + n + "px", this.style.top = o + l.bottom + 2 + i.height + "px", e = r(this.getBoundingClientRect()), s = e.bottom + 8 - window.innerHeight, t && 0 < s && (t = e.height - s, s = 0, this.style.maxHeight = t + "px"), s }, i = (t = !1) => { this.style.maxHeight = null, this.#M.arrow.setAttribute("data-align", "top"); let e = r(this.getBoundingClientRect()), i = r(this.#M.arrow.getBoundingClientRect()), s = 0; return this.#M.arrow.style.top = Math.floor(o + l.top - 2 - n - i.height) + "px", this.style.top = o + l.top - 2 - i.height - e.height + "px", e = r(this.getBoundingClientRect()), s = -(e.top - 8), t && 0 < s && (t = e.height - s, s = 0, this.style.maxHeight = t + "px", this.style.top = o + l.top - 2 - i.height - t + "px"), s }, h = () => { this.style.maxWidth = null; var t = r(this.getBoundingClientRect()); return this.#M.arrow.style.left = a + l.left + l.width / 2 + "px", this.style.left = a + l.left + l.width / 2 - t.width / 2 + "px", [-((t = r(this.getBoundingClientRect())).left - 8), t.right + 8 - window.innerWidth] }, d = (t = !1) => { this.style.maxWidth = null; let e = r(this.getBoundingClientRect()), i = 0; return this.#M.arrow.style.left = a + l.left + l.width / 2 + "px", this.style.left = a + window.innerWidth - 8 - e.width + "px", e = r(this.getBoundingClientRect()), i = -(e.left - 8), t && 0 < i && (t = e.width - i, i = 0, this.style.maxWidth = t + "px", this.style.left = a + window.innerWidth - 8 - t + "px"), i }, u = (t = !1) => { this.style.maxWidth = null; r(this.getBoundingClientRect()); let e, i = 0; return this.#M.arrow.style.left = a + l.left + l.width / 2 + "px", this.style.left = a + 8 + "px", e = r(this.getBoundingClientRect()), i = e.right + 8 - window.innerWidth, t && 0 < i && (t = e.width - i, i = 0, this.style.maxWidth = t + "px"), i }; "bottom" === t ? 0 < (e = s()) && (0 < (c = i()) && (e < c ? s : i)(!0)) : "top" === t && 0 < (e = i()) && 0 < (c = s()) && (e < c ? i : s)(!0); { let [t, e] = h(); 0 < e ? 0 < (t = d()) && d(!0) : 0 < t && (0 < u() && u(!0)) } } else if ("right" === t || "left" === t) { var e = (t = !1) => { this.style.maxWidth = null, this.#M.arrow.setAttribute("data-align", "right"); r(this.getBoundingClientRect()); let e, i = r(this.#M.arrow.getBoundingClientRect()), s = 0; return this.#M.arrow.style.left = a + l.right + 2 + n + "px", this.style.left = a + l.right + 2 + i.width + "px", e = r(this.getBoundingClientRect()), s = e.right + 8 - window.innerWidth, t && 0 < s && (t = e.width - s, s = 0, this.style.maxWidth = t + "px"), s }, c = (t = !1) => { this.style.maxWidth = null, this.#M.arrow.setAttribute("data-align", "left"); let e = r(this.getBoundingClientRect()), i = r(this.#M.arrow.getBoundingClientRect()), s = 0; return this.#M.arrow.style.left = a + l.left - 2 - n - i.width + "px", this.style.left = a + l.left - 2 - i.width - e.width + "px", e = r(this.getBoundingClientRect()), s = -(e.left - 8), t && 0 < s && (t = e.width - s, s = 0, this.style.maxWidth = t + "px", this.style.left = a + l.left - 2 - i.width - t + "px"), s }, i = () => { this.style.maxHeight = null; var t = r(this.getBoundingClientRect()); return this.#M.arrow.style.top = o + l.top + l.height / 2 + "px", this.style.top = o + l.top + l.height / 2 - t.height / 2 + "px", [-((t = r(this.getBoundingClientRect())).top - 8), t.bottom + 8 - window.innerHeight] }, s = (t = !1) => { this.style.maxHeight = null; let e = r(this.getBoundingClientRect()), i = 0; return this.#M.arrow.style.top = o + l.top + l.height / 2 + "px", this.style.top = o + window.innerHeight - 8 - e.height + "px", e = r(this.getBoundingClientRect()), i = -(e.top - 8), t && 0 < i && (t = e.height - i, i = 0, this.style.maxHeight = t + "px", this.style.top = o + window.innerHeight - 8 - t + "px"), i }, h = (t = !1) => { this.style.maxHeight = null; r(this.getBoundingClientRect()); let e, i = 0; return this.#M.arrow.style.top = o + l.top + l.height / 2 + "px", this.style.top = o + 8 + "px", e = r(this.getBoundingClientRect()), i = e.bottom + 8 - window.innerHeight, t && 0 < i && (t = e.height - i, i = 0, this.style.maxHeight = t + "px"), i }; "right" === t ? 0 < (d = e()) && (0 < (u = c()) && (d < u ? e : c)(!0)) : "left" === t && 0 < (d = c()) && 0 < (u = e()) && (d < u ? c : e)(!0); { let [t, e] = i(); 0 < e ? 0 < (t = s()) && s(!0) : 0 < t && (0 < h() && h(!0)) } } } #Ai() { var { backgroundColor: t, borderColor: e, borderWidth: i } = getComputedStyle(this); this.#M["arrow-path"].style.fill = t, this.#M["arrow-path"].style.stroke = e, this.#M["arrow-path"].style.strokeWidth = i } } customElements.define("x-popover", ci); class pi extends HTMLElement { static observedAttributes = ["value", "max", "disabled", "size"]; static #A = Mt`<template><div id="determinate-bar" part="bar"></div><div id="indeterminate-bars"><div id="primary-indeterminate-bar" part="bar"></div><div id="secondary-indeterminate-bar" part="bar"></div></div></template>`; static #L = Tt`:host{display:block;box-sizing:border-box;height:8px;width:100%;position:relative;contain:strict;overflow:hidden;background:#acece6;cursor:default}:host([hidden]){display:none}#indeterminate-bars{width:100%;height:100%}#determinate-bar{position:absolute;top:0;left:0;bottom:0;width:0%;height:100%;background:#3b99fb;box-shadow:0 0 0 1px #3385db;transition:width .4s ease-in-out;will-change:left,right}:host([value="-1"]) #determinate-bar{visibility:hidden}#primary-indeterminate-bar{position:absolute;top:0;left:0;bottom:0;height:100%;background:#3b99fb;will-change:left,right}#secondary-indeterminate-bar{position:absolute;top:0;left:0;bottom:0;height:100%;background:#3b99fb;will-change:left,right}`; get value() { return this.hasAttribute("value") ? parseFloat(this.getAttribute("value")) : null } set value(t) { null === t ? this.removeAttribute("value") : this.setAttribute("value", t) } get max() { return this.hasAttribute("max") ? parseFloat(this.getAttribute("max")) : 1 } set max(t) { this.setAttribute("max", t) } get disabled() { return this.hasAttribute("disabled") } set disabled(t) { t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled") } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } #T = null; #M = {}; #Mi = null; #D = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [pi.#L], this.#T.append(document.importNode(pi.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t } connectedCallback() { Me.addEventListener("sizechange", this.#D = () => this.#F()), this.#J(), this.#F() } disconnectedCallback() { Me.removeEventListener("sizechange", this.#D) } attributeChangedCallback(t, e, i) { e !== i && ("value" === t || "disabled" === t ? this.#J() : "size" === t && this.#F()) } #J() { if (null === this.value || -1 === this.value || this.disabled ? this.#M["determinate-bar"].style.width = "0%" : this.#M["determinate-bar"].style.width = this.value / this.max * 100 + "%", null !== this.value || this.disabled) { if (this.#Mi) { for (var t of this.#Mi) t.cancel(); this.#Mi = null } } else this.#Mi || (this.#Mi = [this.#M["primary-indeterminate-bar"].animate([{ left: "-35%", right: "100%", offset: 0 }, { left: "100%", right: "-90%", offset: .6 }, { left: "100%", right: "-90%", offset: 1 }], { duration: 2e3, easing: "ease-in-out", iterations: 1 / 0 }), this.#M["secondary-indeterminate-bar"].animate([{ left: "-100%", right: "100%", offset: 0 }, { left: "110%", right: "-30%", offset: .8 }, { left: "110%", right: "-30%", offset: 1 }], { duration: 2e3, delay: 1e3, easing: "ease-in-out", iterations: 1 / 0 })]) } #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } } customElements.define("x-progressbar", pi); class mi extends HTMLElement { static observedAttributes = ["toggled", "disabled", "size"]; static #A = Mt`<template><main id="main"><div id="indicator" part="indicator"><div id="indicator-dot" part="indicator-dot"></div></div><div id="description"><slot></slot></div></main></template>`; static #L = Tt`:host{display:block;position:relative;width:fit-content}:host(:focus){outline:0}:host([disabled]){opacity:.4;pointer-events:none}:host([hidden]){display:none}#main{display:flex;align-items:center}#indicator{position:relative;border:3px solid #000;width:19px;height:19px;border-radius:99px;display:flex;align-items:center;justify-content:center}#indicator-dot{width:100%;height:100%;background:currentColor;border-radius:99px;transform:scale(0)}:host([mixed][toggled]) #indicator-dot{height:33%;border-radius:0}:host([toggled]) #indicator-dot{transform:scale(.5)}#description{flex:1}`; get value() { return this.hasAttribute("value") ? this.getAttribute("value") : null } set value(t) { null === t ? this.removeAttribute("value") : this.setAttribute("value", t) } get toggled() { return this.hasAttribute("toggled") } set toggled(t) { t ? this.setAttribute("toggled", "") : this.removeAttribute("toggled") } get mixed() { return this.hasAttribute("mixed") } set mixed(t) { t ? this.setAttribute("mixed", "") : this.removeAttribute("mixed") } get disabled() { return this.hasAttribute("disabled") } set disabled(t) { t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled") } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } #T = null; #M = {}; #ct = 0; #D = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [mi.#L], this.#T.append(document.importNode(mi.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t; this.addEventListener("click", t => this.#I(t)), this.addEventListener("pointerdown", t => this.#pt(t)), this.addEventListener("keydown", t => this.#bt(t)) } connectedCallback() { Me.addEventListener("sizechange", this.#D = () => this.#F()), this.#xt(), this.#F() } disconnectedCallback() { Me.removeEventListener("sizechange", this.#D) } attributeChangedCallback(t) { "toggled" === t ? this.#It() : "disabled" === t ? this.#Ot() : "size" === t && this.#F() } #xt() { this.setAttribute("role", "radio"), this.setAttribute("aria-checked", this.toggled), this.setAttribute("aria-disabled", this.disabled), this.closest("x-radios") || (this.disabled ? (this.#ct = 0 < this.tabIndex ? this.tabIndex : 0, this.tabIndex = -1) : (this.tabIndex < 0 && (this.tabIndex = 0 < this.#ct ? this.#ct : 0), this.#ct = 0)) } #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } #It() { this.setAttribute("aria-checked", this.toggled) } #Ot() { this.#xt() } #I(t) { this.closest("x-radios") || (this.toggled && this.mixed ? this.mixed = !1 : (this.mixed = !1, this.toggled = !this.toggled), this.dispatchEvent(new CustomEvent("toggle", { bubbles: !0 }))) } #pt(e) { if (!1 === this.matches(":focus")) { e.preventDefault(); let t = Ne(this.parentNode, "[tabindex]"); t && t.focus() } } #bt(t) { "Enter" !== t.code && "Space" !== t.code || (t.preventDefault(), this.click()) } } customElements.define("x-radio", mi); class gi extends HTMLElement { get value() { var t = this.querySelector("x-radio[toggled]"); return t ? t.value : null } set value(t) { for (var e of this.querySelectorAll("x-radio")) e.toggled = e.value === t && null !== t } #T = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.innerHTML = "<slot></slot>", this.addEventListener("click", t => this.#I(t), !0), this.addEventListener("keydown", t => this.#bt(t)) } connectedCallback() { this.setAttribute("role", "radiogroup"); let t = [...this.querySelectorAll("x-radio")].filter(t => t.closest("x-radios") === this), e = t.find(t => t.toggled && !t.disabled) || t.find(t => !t.disabled); for (var i of t) i.setAttribute("tabindex", i === e ? "0 " : "-1"), i.setAttribute("aria-checked", i === e) } #I(t) { let e = t.target.closest("x-radio"); if (e && !e.toggled && !e.disabled && t.buttons <= 1) { t = [...this.querySelectorAll("x-radio")].filter(t => t.closest("x-radios") === this && t !== e); if (!1 === e.toggled || !0 === e.mixed) { e.toggled = !0, e.mixed = !1, e.tabIndex = 0; for (var i of t) i.toggled = !1, i.tabIndex = -1; this.dispatchEvent(new CustomEvent("toggle", { bubbles: !0, detail: e })) } } } #bt(n) { var t = n["key"]; if ("ArrowDown" === t || "ArrowRight" === t) { let t = [...this.querySelectorAll("x-radio")], i = t.filter(t => !1 === t.disabled && t.closest("x-radios") === this), s = t.find(t => t.matches(":focus")); if (s) { let t = i.indexOf(s), e = 1 < i.length ? i[t + 1] || i[0] : null; e && (n.preventDefault(), e.focus(), e.tabIndex = 0, s.tabIndex = -1) } } else if ("ArrowUp" === t || "ArrowLeft" === t) { let t = [...this.querySelectorAll("x-radio")], s = t.filter(t => !1 === t.disabled && t.closest("x-radios") === this), r = t.find(t => t.matches(":focus")); if (r) { let t = s.indexOf(r), e = s[s.length - 1], i = 1 < s.length ? s[t - 1] || e : null; i && (n.preventDefault(), i.focus(), i.tabIndex = 0, r.tabIndex = -1) } } } } customElements.define("x-radios", gi); class bi extends HTMLElement {
    static observedAttributes = ["value", "size"]; static #A = Mt`<template><x-box vertical><div id="hue-slider" part="slider"><div id="hue-slider-track"><div id="hue-slider-marker"></div></div></div><div id="satlight-slider" part="slider"><div id="satlight-marker"></div></div><div id="alpha-slider" part="slider"><div id="alpha-slider-gradient"></div><div id="alpha-slider-track"><div id="alpha-slider-marker"></div></div></div></x-box></template>`; static #L = Tt`:host{display:block;width:100%;user-select:none}:host([hidden]){display:none}#hue-slider{width:100%;height:30px;padding:0 calc(var(--marker-width)/ 2);margin-bottom:14px;box-sizing:border-box;border-radius:2px;touch-action:pan-y;--marker-width:18px;background:red}:host([computedsize=small]) #hue-slider{height:24px}:host([computedsize=large]) #hue-slider{height:35px}#hue-slider-track{width:100%;height:100%;position:relative;display:flex;align-items:center;background:linear-gradient(to right,red,#ff0,#0f0,#0ff,#00f,#f0f,red)}#hue-slider-marker{position:absolute;left:0;background:rgba(0,0,0,.2);box-shadow:0 0 3px #000;box-sizing:border-box;transform:translateX(calc((var(--marker-width)/ 2) * -1));border:3px solid #fff;width:var(--marker-width);height:calc(100% + 6px);position:absolute}#satlight-slider{width:100%;height:174px;border-radius:2px;position:relative;touch-action:pinch-zoom}#satlight-marker{position:absolute;top:0;left:0;width:var(--marker-size);height:var(--marker-size);transform:translate(calc(var(--marker-size)/ -2),calc(var(--marker-size)/ -2));box-sizing:border-box;background:rgba(0,0,0,.3);border:3px solid #fff;border-radius:999px;box-shadow:0 0 3px #000;--marker-size:20px}#alpha-slider{position:relative;display:none;width:100%;height:30px;margin-top:14px;padding:0 calc(var(--marker-width)/ 2);box-sizing:border-box;border-radius:2px;touch-action:pan-y;--marker-width:18px;background-size:10px 10px;background-position:0 0,0 5px,5px -5px,-5px 0;background-image:linear-gradient(45deg,#d6d6d6 25%,transparent 25%),linear-gradient(-45deg,#d6d6d6 25%,transparent 25%),linear-gradient(45deg,transparent 75%,#d6d6d6 75%),linear-gradient(-45deg,transparent 75%,#d6d6d6 75%)}:host([alphaslider]) #alpha-slider{display:block}:host([computedsize=small]) #alpha-slider{height:24px}:host([computedsize=large]) #alpha-slider{height:35px}#alpha-slider-gradient{position:absolute;top:0;left:0;width:100%;height:100%}#alpha-slider-track{width:100%;height:100%;position:relative;display:flex;align-items:center}#alpha-slider-marker{position:absolute;left:0;background:rgba(0,0,0,.2);box-shadow:0 0 3px #000;box-sizing:border-box;transform:translateX(calc((var(--marker-width)/ 2) * -1));border:3px solid #fff;width:var(--marker-width);height:calc(100% + 6px);position:absolute}`; get value() { return this.hasAttribute("value") ? this.getAttribute("value") : "hsla(0, 0%, 100%, 1)" } set value(t) { this.setAttribute("value", t) } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } #T = null; #M = {}; #D = null; #j = 0; #H = 0; #Ti = 100; #q = 1; #K = !1; #$i = !1; #Z = !1; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [bi.#L], this.#T.append(document.importNode(bi.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t; this.#M["hue-slider"].addEventListener("pointerdown", t => this.#G(t)), this.#M["satlight-slider"].addEventListener("pointerdown", t => this.#Di(t)), this.#M["alpha-slider"].addEventListener("pointerdown", t => this.#_(t)) } connectedCallback() { this.#J(), this.#F(), Me.addEventListener("sizechange", this.#D = () => this.#F()) } disconnectedCallback() { Me.removeEventListener("sizechange", this.#D) } attributeChangedCallback(t, e, i) { e !== i && ("value" === t ? this.#Q() : "size" === t && this.#tt()) } #J() { this.#et(), this.#Ri(), this.#Pi(), this.#rt(), this.#ht() } #et() { this.#M["hue-slider-marker"].style.left = h(this.#j, 0, 360, 0) / 360 * 100 + "%" } #Ri() { var t = this.#H / 100 * 100, e = 100 - this.#Ti / 100 * 100; this.#M["satlight-marker"].style.left = t + "%", this.#M["satlight-marker"].style.top = e + "%" } #Pi() { var t = v([this.#j, 100, 50, 1], "hsla", "hex"); this.#M["satlight-slider"].style.background = "linear-gradient(to bottom, rgba(0,0,0,0), rgba(0,0,0,1)), linear-gradient(to left, rgba(255,255,255,0), rgba(255,255,255,1)), " + t } #rt() { this.#M["alpha-slider-marker"].style.left = h(100 * (1 - this.#q), 0, 100, 2) + "%" } #ht() {
        var [t, e, i] = w(this.#j, this.#H, this.#Ti).map(t => o(t, 0)); this.#M["alpha-slider-gradient"].style.background = `
      linear-gradient(to right, rgba(${t}, ${e}, ${i}, 1), rgba(${t}, ${e}, ${i}, 0))
    `} #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } #Q() { var t, e, i, s; !1 === this.#K && !1 === this.#$i && !1 === this.#Z && ([t, e, i, s] = (new E).parse(this.value, "hsva"), this.#j = t, this.#H = e, this.#Ti = i, this.#q = s, this.#J()) } #tt() { this.#F() } #Di(t) { if (!(1 < t.buttons)) { let e, i, s = this.#M["satlight-slider"].getBoundingClientRect(), r = (this.#$i = !0, this.dispatchEvent(new CustomEvent("changestart", { bubbles: !0 })), this.#M["satlight-slider"].setPointerCapture(t.pointerId), (t, e) => { t = (t - s.left) / s.width * 100, e = (e - s.top) / s.height * 100, t = h(t, 0, 100, 2), e = h(e, 0, 100, 2); this.#H = t, this.#Ti = 100 - e, this.value = v([this.#j, this.#H, this.#Ti, this.#q], "hsva", "hsla"), this.dispatchEvent(new CustomEvent("change", { bubbles: !0 })), this.#Ri(), this.#Pi(), this.#ht() }); r(t.clientX, t.clientY), this.#M["satlight-slider"].addEventListener("pointermove", e = t => { r(t.clientX, t.clientY) }), this.#M["satlight-slider"].addEventListener("pointerup", i = t => { this.#M["satlight-slider"].removeEventListener("pointermove", e), this.#M["satlight-slider"].removeEventListener("pointerup", i), this.dispatchEvent(new CustomEvent("changeend", { bubbles: !0 })), this.#$i = !1 }) } } #G(r) { if (!(1 < r.buttons)) { let t, e, i = this.#M["hue-slider-track"].getBoundingClientRect(), s = (this.#K = !0, this.#M["hue-slider"].setPointerCapture(r.pointerId), this.dispatchEvent(new CustomEvent("changestart", { bubbles: !0 })), t => { t = (t - i.x) / i.width * 360; (t = h(t, 0, 360, 0)) !== this.#j && (this.#j = t, this.value = v([this.#j, this.#H, this.#Ti, this.#q], "hsva", "hsla"), this.#et(), this.#Pi(), this.#Ri(), this.#ht(), this.dispatchEvent(new CustomEvent("change", { bubbles: !0 }))) }); s(r.clientX), this.#M["hue-slider"].addEventListener("pointermove", t = t => { s(t.clientX) }), this.#M["hue-slider"].addEventListener("pointerup", e = () => { this.#M["hue-slider"].removeEventListener("pointermove", t), this.#M["hue-slider"].removeEventListener("pointerup", e), this.dispatchEvent(new CustomEvent("changeend", { bubbles: !0 })), this.#K = !1 }) } } #_(r) { if (!(1 < r.buttons)) { let t, e, i = this.#M["alpha-slider-track"].getBoundingClientRect(), s = (this.#Z = !0, this.#M["alpha-slider"].setPointerCapture(r.pointerId), this.dispatchEvent(new CustomEvent("changestart", { bubbles: !0 })), t => { t = 1 - (t - i.x) / i.width; (t = h(t, 0, 1, 2)) !== this.#q && (this.#q = t, this.value = v([this.#j, this.#H, this.#Ti, this.#q], "hsva", "hsla"), this.#rt(), this.dispatchEvent(new CustomEvent("change", { bubbles: !0 }))) }); s(r.clientX), this.#M["alpha-slider"].addEventListener("pointermove", t = t => { s(t.clientX) }), this.#M["alpha-slider"].addEventListener("pointerup", e = () => { this.#M["alpha-slider"].removeEventListener("pointermove", t), this.#M["alpha-slider"].removeEventListener("pointerup", e), this.dispatchEvent(new CustomEvent("changeend", { bubbles: !0 })), this.#Z = !1 }) } }
} customElements.define("x-rectcolorpicker", bi); let fi = Symbol(); class xi extends HTMLElement { static observedAttributes = ["disabled", "size"]; static #A = Mt`<template><div id="button"><div id="arrow-container"><svg id="arrow" part="arrow" viewBox="0 0 100 100" preserveAspectRatio="none"><path></path></svg></div></div><slot></slot></template>`; static #L = Tt`:host{display:block;width:fit-content;height:32px;padding:0 0 0 9px;max-width:100%;box-sizing:border-box;position:relative;outline:0;font-size:14px;user-select:none}:host([disabled]){pointer-events:none;opacity:.5}:host([hidden]){display:none}:host(:hover){cursor:default}#button{display:flex;flex-flow:row;align-items:center;justify-content:flex-start;flex:1;width:100%;height:100%}:host([mixed]) #button>*{opacity:.7}#button>x-label{white-space:nowrap;text-overflow:ellipsis;overflow:hidden}#button>#arrow-container{margin:0 0 0 auto;z-index:999}#button>#arrow-container #arrow{display:flex;width:13px;height:13px;min-width:13px;margin:0 2px 0 11px;color:currentColor;d:path("M 25 41 L 50 16 L 75 41 L 83 34 L 50 1 L 17 34 Z M 17 66 L 50 100 L 83 66 L 75 59 L 50 84 L 25 59 Z")}#button>#arrow-container #arrow path{fill:currentColor;d:inherit}`; get value() { var t = this.querySelector("x-menuitem[toggled]"); return t ? t.value : null } set value(t) { for (var e of this.querySelectorAll("x-menuitem")) e.toggled = e.value === t && null !== t } get mixed() { return this.hasAttribute("mixed") } set mixed(t) { t ? this.setAttribute("mixed", "") : this.removeAttribute("mixed") } get disabled() { return this.hasAttribute("disabled") } set disabled(t) { t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled") } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } #T = null; #M = {}; #ct = 0; #dt = !1; #Ii = null; #Oi = null; #D = null; #Fi = new MutationObserver(t => this.#Bi(t)); #$ = new ResizeObserver(() => this.#Ni()); constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [xi.#L], this.#T.append(document.importNode(xi.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t; this.#M.backdrop = Be("x-backdrop"), this.#M.backdrop.style.opacity = "0", (this.#M.backdrop.ownerElement = this).#M.backdrop.addEventListener("click", t => this.#ji(t)), this.addEventListener("pointerdown", t => this.#pt(t)), this.addEventListener("toggle", t => this.#Hi(t)), this.addEventListener("click", t => this.#I(t)), this.addEventListener("keydown", t => this.#bt(t)) } connectedCallback() { this.#Fi.observe(this, { childList: !0, attributes: !0, characterData: !0, subtree: !0 }), this.#$.observe(this), this.#Ui(), this.#xt(), this.#F(), Me.addEventListener("sizechange", this.#D = () => this.#F()) } disconnectedCallback() { this.#Fi.disconnect(), this.#$.disconnect(), Me.removeEventListener("sizechange", this.#D) } attributeChangedCallback(t) { "disabled" === t ? this.#xt() : "size" === t && this.#F() } #Ht() { if (!1 !== this.#qi()) { this.#dt = this.matches(":focus"), this.#M.backdrop.show(!1), window.addEventListener("resize", this.#Ii = () => { this.#Ut() }), window.addEventListener("blur", this.#Oi = () => { this.#Ut() }); let e = this.querySelector(":scope > x-menu"); { let t = null; for (var i of e.querySelectorAll("x-menuitem")) i.togglable = !0, i.toggled && (null === t ? t = i : i.toggled = !1) } e.querySelector("x-menuitem[toggled]") ? (t = (s = this.#M.button.querySelector("x-label") || this.#M.button.firstElementChild)[fi], e.openOverElement(s, t)) : (s = e.querySelector("x-menuitem").firstElementChild, e.openOverElement(this.#M.button, s)); var t = e.getBoundingClientRect(), s = this.#M.button.getBoundingClientRect(), r = parseFloat(getComputedStyle(this).paddingRight), s = (t.right - r < s.right && (e.style.minWidth = s.right - t.left + r + "px"), this.getBoundingClientRect()); s.right + 7 > window.innerWidth && (this.style.maxWidth = window.innerWidth - s.left - 7 + "px") } } async#Ut(e = null) { if (!1 !== this.#Ki()) { let t = this.querySelector(":scope > x-menu"); if (t.setAttribute("closing", ""), await e, this.#M.backdrop.hide(!1), this.#dt) this.focus(); else { let t = Ne(this.parentNode, "[tabindex]"); t && t.focus() } window.removeEventListener("resize", this.#Ii), window.removeEventListener("blur", this.#Oi), await t.close(), t.removeAttribute("closing") } } #qi() { if (this.disabled) return !1; { let t = this.querySelector(":scope > x-menu"), e = t.querySelector("x-menuitem"); return null !== t && !1 === t.opened && !1 === t.hasAttribute("closing") && null !== e } } #Ki() { if (this.disabled) return !1; { let t = this.querySelector(":scope > x-menu"); return t.querySelector("x-menuitem"), null !== t && !0 === t.opened && !1 === t.hasAttribute("closing") } } #Ui() { var t = this.querySelector(":scope > x-menu x-menuitem[toggled]"); if (this.#M.button.innerHTML = "", t) { for (var e of t.children) { let t = e.cloneNode(!0); t[fi] = e, t.removeAttribute("id"), t.removeAttribute("style"), this.#M.button.append(t) } this.#Vi() } this.#M.button.append(this.#M["arrow-container"]) } #Xi = Ae(this.#Ui, 300, this); #Vi() { for (var t of this.#M.button.children) { var e, i, s, r, n, a; t !== this.#M["arrow-container"] && ({ width: e, height: i, margin: s, padding: r, border: n, borderRadius: a } = getComputedStyle(t[fi]), ["x-icon", "x-swatch", "img", "svg"].includes(t[fi].localName) && (t.style.width = e, t.style.height = i, t.style.minWidth = e, t.style.borderRadius = a), t.style.margin = s, t.style.padding = r, t.style.border = n) } } #xt() { this.setAttribute("aria-disabled", this.disabled), this.disabled ? (this.#ct = 0 < this.tabIndex ? this.tabIndex : 0, this.tabIndex = -1) : (this.tabIndex < 0 && (this.tabIndex = 0 < this.#ct ? this.#ct : 0), this.#ct = 0); { this.setAttribute("role", "button"); let t = this.querySelector(":scope > x-menu"); if (t) { t.setAttribute("role", "listbox"); for (var e of t.querySelectorAll("x-menuitem")) e.setAttribute("role", "option") } } } #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } #Bi(t) { for (var e of t) "attributes" === e.type && "x-menuitem" === e.target.localName && "toggled" === e.attributeName && this.#Xi() } #Ni() { this.#Vi() } #pt(t) { t.target.closest("x-menu") || !1 !== this.matches(":focus") || t.preventDefault() } async#I(t) { if (!(1 < t.buttons)) if (this.#qi()) this.#Ht(); else if (this.#Ki()) { var e = t.target.closest("x-menuitem"); if (e) { var i, t = this.value, s = e.value; for (i of this.querySelectorAll("x-menuitem")) i.toggled = i === e; await this.#Ut(e.whenTriggerEnd), t === s && !this.mixed || (this.mixed = !1, this.dispatchEvent(new CustomEvent("change", { bubbles: !0, detail: { oldValue: t, newValue: s } }))) } } } #Hi(t) { t.preventDefault() } #ji(t) { this.#Ut() } #bt(t) { !1 === t.defaultPrevented && (this.querySelector(":scope > x-menu"), "Enter" === t.key || "Space" === t.key || "ArrowUp" === t.key || "ArrowDown" === t.key ? this.#qi() && (t.preventDefault(), this.#Ht()) : "Escape" === t.key && this.#Ki() && (t.preventDefault(), this.#Ut())) } } customElements.define("x-select", xi); const wi = navigator.platform.startsWith("Mac") || ["iPhone", "iPad"].includes(navigator.platform), vi = ["Alt", "AltGraph", "CapsLock", "Control", "Fn", "FnLock", "Meta", "NumLock", "ScrollLock", "Shift", "Symbol", "SymbolLock"]; class yi extends HTMLElement { static observedAttributes = ["value"]; static #A = Mt`<template><main id="main"></main></template>`; static #L = Tt`:host{display:inline-block;box-sizing:border-box;font-size:14px;line-height:1}:host([hidden]){display:none}::selection{color:var(--selection-color);background-color:var(--selection-background-color)}`; get value() { let e = []; if (this.hasAttribute("value")) { let t = this.getAttribute("value").replace("++", "+PLUS").split("+"); t = t.map(t => t.trim().replace("PLUS", "+")).filter(t => "" !== t), e = t } return e } set value(t) { this.setAttribute("value", t.join("+")) } get modKeys() { return this.value.filter(t => vi.includes(t)) } get normalKey() { var t = this.value.find(t => !1 === vi.includes(t)); return void 0 === t ? null : t } #T = null; #M = {}; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [yi.#L], this.#T.append(document.importNode(yi.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t } attributeChangedCallback(t) { "value" === t && this.#J() } #J() { let e = "", i = (this.value, this.modKeys), s = this.normalKey; if (wi) i.includes("Meta") && (e += "^"), i.includes("Alt") && (e += "⌥"), i.includes("Shift") && (e += "⇧"), i.includes("Control") && (e += "⌘"), i.includes("Symbol") && (e += "☺"), void 0 !== s && (e += { ArrowUp: "↑", ArrowDown: "↓", ArrowLeft: "←", ArrowRight: "→", Backspace: "⌦" }[s] || s); else { let t = []; i.includes("Control") && t.push("Ctrl"), i.includes("Alt") && t.push("Alt"), i.includes("Meta") && t.push("Meta"), i.includes("Shift") && t.push("Shift"), i.includes("Symbol") && t.push("Symbol"), null !== s && t.push({ ArrowUp: "Up", ArrowDown: "Down", ArrowLeft: "Left", ArrowRight: "Right" }[s] || s), e = t.join("+") } this.#M.main.textContent = e } } customElements.define("x-shortcut", yi); class ki extends HTMLElement { static observedAttributes = ["value", "buffer", "min", "max", "size"]; static #A = Mt`<template><main id="main"><div id="tracks-and-thumbs"><div id="groove-track" part="track groove-track"></div><div id="buffer-track" part="track buffer-track"></div><div id="range-track" part="track range-track"></div><div id="thumbs"><div id="start-thumb" class="thumb" part="thumb start-thumb" data-value="start" tabindex="0"></div><div id="end-thumb" class="thumb" part="thumb end-thumb" data-value="end" tabindex="0"></div></div></div><div id="ticks"></div><div id="labels"><slot></slot></div></main></template>`; static #L = Tt`:host{display:block;width:100%;position:relative;box-sizing:border-box;touch-action:pan-y}:host(:focus){outline:0}:host(:hover){cursor:default}:host([disabled]){pointer-events:none;opacity:.4}:host([vertical]){width:fit-content;height:200px}#main{display:flex;flex-flow:column;width:100%;height:100%}:host([vertical]) #main{flex-flow:row}#tracks-and-thumbs{position:relative;width:100%;height:100%}#range-track{position:absolute;width:0%;height:4px;background:#000;top:50%;transform:translateY(-50%)}:host([vertical]) #range-track{width:4px;height:0%;top:initial;left:50%;transform:translateX(-50%)}#groove-track{position:absolute;width:100%;height:4px;background:gray;top:50%;transform:translateY(-50%)}:host([vertical]) #groove-track{width:4px;height:100%;top:initial;left:50%;transform:translateX(-50%)}#buffer-track{position:absolute;width:0%;height:4px;background:red;top:50%;transform:translateY(-50%)}:host([vertical]) #buffer-track{width:4px;height:0%;top:initial;left:50%;transform:translateX(-50%)}#thumbs{position:relative;width:calc(100% - var(--computed-thumb-width));height:100%;margin:0 auto}:host([vertical]) #thumbs{height:calc(100% - var(--computed-thumb-height));width:100%;margin:auto 0}#thumbs .thumb{position:absolute;top:0;left:0;width:20px;height:20px;margin-left:calc(var(--computed-thumb-width)/ -2);box-sizing:border-box;background:gray;border:1px solid rgba(0,0,0,.2)}:host([vertical]) #thumbs .thumb{margin-left:0}#thumbs .thumb:first-child{position:relative}#thumbs .thumb:focus{outline:0;z-index:2}#ticks{position:relative;width:calc(100% - var(--computed-thumb-width));margin:0 calc(var(--computed-thumb-width)/ 2)}:host([vertical]) #ticks{width:initial;height:calc(100% - var(--computed-thumb-height));margin:calc(var(--computed-thumb-height)/ 2) 0}#ticks:empty{display:none}#ticks .tick{position:absolute;left:0;top:0;width:1px;height:5px;background:rgba(0,0,0,.4)}:host([vertical]) #ticks .tick{width:5px;height:1px;left:0;top:0}#ticks .tick:first-child{position:relative}#labels{position:relative;width:calc(100% - var(--computed-thumb-width));margin:0 calc(var(--computed-thumb-width)/ 2)}:host([vertical]) #labels{width:initial;height:calc(100% - var(--computed-thumb-height));margin:calc(var(--computed-thumb-height)/ 2) 0}:host(:empty) #labels{display:none}::slotted(x-label){display:inline-block;top:0;position:absolute;vertical-align:top;transform:translateX(-50%);white-space:nowrap}:host([vertical]) ::slotted(x-label){top:initial;left:4px;transform:translateY(-50%)}`; get min() { return this.hasAttribute("min") ? parseFloat(this.getAttribute("min")) : 0 } set min(t) { this.setAttribute("min", t) } get max() { return this.hasAttribute("max") ? parseFloat(this.getAttribute("max")) : 100 } set max(t) { this.setAttribute("max", t) } get value() { if (this.hasAttribute("value")) { let t = this.getAttribute("value").split(/[ ,]+/); return 2 <= t.length ? t.map(t => parseFloat(t)).slice(0, 2) : parseFloat(t[0]) } return this.max >= this.min ? this.min + (this.max - this.min) / 2 : this.min } set value(t) { Array.isArray(t) ? ((t = t.map(t => h(t, this.min, this.max))).length = 2, this.setAttribute("value", t.join(" "))) : (t = h(t, this.min, this.max), this.setAttribute("value", t)) } get buffer() { if (this.hasAttribute("buffer")) { let t = this.getAttribute("buffer").split(/[ ,]+/); return 2 <= t.length ? t.map(t => parseFloat(t)).slice(0, 2) : [0, parseFloat(t[0])] } return [0, 0] } set buffer(t) { (t = t.map(t => h(t, this.min, this.max))).length = 2, this.setAttribute("buffer", t.join(" ")) } get step() { return this.hasAttribute("step") ? parseFloat(this.getAttribute("step")) : 1 } set step(t) { this.setAttribute("step", t) } get vertical() { return this.hasAttribute("vertical") } set vertical(t) { t ? this.setAttribute("vertical", "") : this.removeAttribute("vertical") } get disabled() { return this.hasAttribute("disabled") } set disabled(t) { t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled") } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } get dragging() { return this.getAttribute("dragging") } #T = null; #M = {}; #ct = 0; #D = null; #Fi = new MutationObserver(t => this.#Bi(t)); #Zi = new ResizeObserver(() => this.#Gi()); constructor() { super(), this.#T = this.attachShadow({ mode: "closed", delegatesFocus: !0 }), this.#T.adoptedStyleSheets = [ki.#L], this.#T.append(document.importNode(ki.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t; this.#T.addEventListener("pointerdown", t => this.#ri(t)), this.addEventListener("pointerdown", t => this.#pt(t)), this.addEventListener("keydown", t => this.#bt(t)) } connectedCallback() { this.setAttribute("value", this.value), Me.addEventListener("sizechange", this.#D = () => this.#F()), this.#Zi.observe(this.#M["start-thumb"]), this.#Fi.observe(this, { childList: !0, subtree: !0, attributes: !0, attributeFilter: ["value"], characterData: !1 }), this.#Wi(), this.#Yi(), this.#_i(), this.#xt(), this.#F() } disconnectedCallback() { Me.removeEventListener("sizechange", this.#D), this.#Zi.unobserve(this.#M["start-thumb"]), this.#Fi.disconnect() } attributeChangedCallback(t, e, i) { e !== i && ("value" === t ? this.#Q() : "buffer" === t ? this.#Ji() : "min" === t ? this.#pi() : "max" === t ? this.#mi() : "size" === t && this.#tt()) } #Q() { this.#Wi(), this.#Yi() } #Ji() { this.#Wi() } #pi() { this.#Wi(), this.#Yi(), this.#_i() } #mi() { this.#Wi(), this.#Yi(), this.#_i() } #tt() { this.#F() } #Bi(t) { for (var e of t) { if ("attributes" === e.type && e.target === this) return; this.#Qi() } } #Gi() { var t = this.#M["start-thumb"].getBoundingClientRect(); this.#M.main.style.setProperty("--computed-thumb-width", t.width + "px"), this.#M.main.style.setProperty("--computed-thumb-height", t.height + "px") } #pt(e) { if (!1 === this.matches(":focus")) { e.preventDefault(); let t = Ne(this.parentNode, "[tabindex]"); t && t.focus() } } #ri(c) { if (!(1 < c.buttons || !1 === c.isPrimary)) { let t, e, s = null, { width: r, height: n } = this.#M["start-thumb"].getBoundingClientRect(), d = this.#M.main.getBoundingClientRect(), u = !1; var p, m, g, b; s = c.target.matches(".thumb") ? c.target : !0 === this.#M["end-thumb"].hidden ? this.#M["start-thumb"] : (p = this.#M["start-thumb"].getBoundingClientRect(), m = this.#M["end-thumb"].getBoundingClientRect(), p = new DOMPoint(p.x + p.width / 2, p.y + p.height / 2), m = new DOMPoint(m.x + m.width / 2, m.y + m.height / 2), g = new DOMPoint(c.clientX, c.clientY), l(g, p) <= l(g, m) ? this.#M["start-thumb"] : this.#M["end-thumb"]); let i = (t, e) => { let i = 0; var t = i = this.vertical ? (e = d.y + d.height - n / 2 - e, (e = h(e, 0, d.height - n)) / (d.height - n) * (this.max - this.min) + this.min) : (e = t - (d.x + r / 2), (e = h(e, 0, d.width - r)) / (d.width - r) * (this.max - this.min) + this.min), e = this.step; i = o(o(t / e) * e, a(e)), Array.isArray(this.value) ? ([t, e] = this.value, s === this.#M["start-thumb"] ? (i = i >= e ? e : i) !== t && (!(this.value = [i, e]) === u && (u = !0, this.dispatchEvent(new CustomEvent("changestart", { bubbles: !0 }))), this.dispatchEvent(new CustomEvent("change", { bubbles: !0 }))) : s === this.#M["end-thumb"] && (i = i <= t ? t : i) !== e && (!(this.value = [t, i]) === u && (u = !0, this.dispatchEvent(new CustomEvent("changestart", { bubbles: !0 }))), this.dispatchEvent(new CustomEvent("change", { bubbles: !0 })))) : this.value !== i && (this.value = i, !1 === u && (u = !0, this.dispatchEvent(new CustomEvent("changestart", { bubbles: !0 }))), this.dispatchEvent(new CustomEvent("change", { bubbles: !0 }))) }; s.setPointerCapture(c.pointerId), this.setAttribute("dragging", s.dataset.value), i(c.clientX, c.clientY); for (b of this.#M.thumbs.children) b.style.zIndex = b === s ? "1" : "0"; s.addEventListener("pointermove", t = t => { t.isPrimary && i(t.clientX, t.clientY) }), s.addEventListener("pointerup", e = () => { s.removeEventListener("pointermove", t), s.removeEventListener("pointerup", e), this.removeAttribute("dragging"), u && this.dispatchEvent(new CustomEvent("changeend", { bubbles: !0 })) }) } } #bt(i) { if ("ArrowLeft" === i.code || "ArrowDown" === i.code) { i.preventDefault(), this.dispatchEvent(new CustomEvent("changestart", { bubbles: !0 })); var s = this.value; if (Array.isArray(this.value)) { let [t, e] = this.value; this.#T.activeElement === this.#M["start-thumb"] ? i.shiftKey ? t -= 10 * this.step : t -= this.step : this.#T.activeElement === this.#M["end-thumb"] && (i.shiftKey ? e -= 10 * this.step : e -= this.step, e <= t && (e = t)), !(this.value = [t, e]) === At(s, this.value) && this.dispatchEvent(new CustomEvent("change", { bubbles: !0 })) } else i.shiftKey ? this.value -= 10 * this.step : this.value -= this.step, s !== this.value && this.dispatchEvent(new CustomEvent("change", { bubbles: !0 })); this.dispatchEvent(new CustomEvent("changeend", { bubbles: !0 })) } else if ("ArrowRight" === i.code || "ArrowUp" === i.code) { i.preventDefault(), this.dispatchEvent(new CustomEvent("changestart", { bubbles: !0 })); s = this.value; if (Array.isArray(this.value)) { let [t, e] = this.value; this.#T.activeElement === this.#M["start-thumb"] ? (i.shiftKey ? t += 10 * this.step : t += this.step, t >= e && (t = e)) : this.#T.activeElement === this.#M["end-thumb"] && (i.shiftKey ? e += 10 * this.step : e += this.step), !(this.value = [t, e]) === At(s, this.value) && this.dispatchEvent(new CustomEvent("change", { bubbles: !0 })) } else i.shiftKey ? this.value += 10 * this.step : this.value += this.step, s !== this.value && this.dispatchEvent(new CustomEvent("change", { bubbles: !0 })); this.dispatchEvent(new CustomEvent("changeend", { bubbles: !0 })) } } #Yi() { var t, e; Array.isArray(this.value) ? ([t, e] = this.value, t = (t - this.min) / (this.max - this.min) * 100, this.vertical ? this.#M["start-thumb"].style.top = 100 - t + "%" : this.#M["start-thumb"].style.left = t + "%", this.#M["start-thumb"].hidden = !1, t = (e - this.min) / (this.max - this.min) * 100, this.vertical ? this.#M["end-thumb"].style.top = 100 - t + "%" : this.#M["end-thumb"].style.left = t + "%", this.#M["end-thumb"].hidden = !1) : (e = (this.value - this.min) / (this.max - this.min) * 100, this.vertical ? this.#M["start-thumb"].style.top = 100 - e + "%" : this.#M["start-thumb"].style.left = e + "%", this.#M["start-thumb"].hidden = !1, this.#M["end-thumb"].hidden = !0) } #Wi() { Array.isArray(this.value) ? ([t, e] = this.value, t = (t - this.min) / (this.max - this.min) * 100, e = (e - this.min) / (this.max - this.min) * 100, this.vertical ? (this.#M["range-track"].style.bottom = t + "%", this.#M["range-track"].style.height = e - t + "%") : (this.#M["range-track"].style.left = t + "%", this.#M["range-track"].style.width = e - t + "%")) : (e = (this.value - this.min) / (this.max - this.min) * 100, t = ((0 < this.min ? this.min : 0) - this.min) / (this.max - this.min) * 100, this.vertical ? t <= e ? (this.#M["range-track"].style.bottom = t + "%", this.#M["range-track"].style.height = e - t + "%") : (this.#M["range-track"].style.bottom = e + "%", this.#M["range-track"].style.height = t - e + "%") : t <= e ? (this.#M["range-track"].style.left = t + "%", this.#M["range-track"].style.width = e - t + "%") : (this.#M["range-track"].style.left = e + "%", this.#M["range-track"].style.width = t - e + "%")); var [t, e] = this.buffer, t = (t - this.min) / (this.max - this.min) * 100, e = (e - this.min) / (this.max - this.min) * 100; this.vertical ? (this.#M["buffer-track"].style.bottom = t + "%", this.#M["buffer-track"].style.height = e - t + "%") : (this.#M["buffer-track"].style.left = t + "%", this.#M["buffer-track"].style.width = e - t + "%") } async#_i() { await customElements.whenDefined("x-label"), this.#M.ticks.innerHTML = ""; for (var t of this.querySelectorAll(":scope > x-label")) this.vertical ? t.style.top = 100 - (t.value - this.min) / (this.max - this.min) * 100 + "%" : t.style.left = (t.value - this.min) / (this.max - this.min) * 100 + "%", t === this.firstElementChild ? t.style.position = "relative" : t.style.position = null, this.vertical ? this.#M.ticks.insertAdjacentHTML("beforeend", `<div class="tick" part="tick" style="top: ${t.style.top}"></div>`) : this.#M.ticks.insertAdjacentHTML("beforeend", `<div class="tick" part="tick" style="left: ${t.style.left}"></div>`) } #Qi = Ae(this.#_i, 500, this); #xt() { this.setAttribute("aria-disabled", this.disabled), this.disabled ? (this.#ct = 0 < this.tabIndex ? this.tabIndex : 0, this.tabIndex = -1) : (this.tabIndex < 0 && (this.tabIndex = 0 < this.#ct ? this.#ct : 0), this.#ct = 0) } #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } } customElements.define("x-slider", ki); class zi extends HTMLElement { static observedAttributes = ["disabled"]; static #A = Mt`<template><div id="decrement-button" part="decrement-button" class="button"><svg id="decrement-arrow" part="decrement-arrow" viewBox="0 0 100 100" preserveAspectRatio="none"><path id="decrement-arrow-path"></path></svg></div><div id="increment-button" part="increment-button" class="button"><svg id="increment-arrow" part="increment-arrow" viewBox="0 0 100 100" preserveAspectRatio="none"><path id="increment-arrow-path"></path></svg></div></template>`; static #L = Tt`:host{display:flex;flex-flow:column-reverse;align-items:center;justify-content:center;box-sizing:border-box;height:100%;width:fit-content;color:rgba(0,0,0,.6)}:host(:hover){cursor:default}:host([disabled=""]){opacity:.5;pointer-events:none}.button{display:flex;align-items:center;justify-content:center;width:100%;height:100%;user-select:none;box-sizing:border-box;color:inherit;border-left:none}.button[data-pressed]{color:#fff;background:rgba(0,0,0,.3)}:host([disabled=decrement]) #decrement-button,:host([disabled=increment]) #increment-button{opacity:.3;pointer-events:none}#increment-arrow{width:11px;height:11px;pointer-events:none;d:path("M 24 69 L 50 43 L 76 69 L 69 76 L 50 58 L 31 76 L 24 69 Z" )}#decrement-arrow{width:11px;height:11px;pointer-events:none;d:path("M 24 32 L 50 58 L 76 32 L 69 25 L 50 44 L 31 25 L 24 32 Z" )}#decrement-arrow-path,#increment-arrow-path{d:inherit;fill:currentColor}`; get disabled() { return !!this.hasAttribute("disabled") && ("increment" === this.getAttribute("disabled") ? "increment" : "decrement" !== this.getAttribute("disabled") || "decrement") } set disabled(t) { !0 === t ? this.setAttribute("disabled", "") : !1 === t ? this.removeAttribute("disabled") : this.setAttribute("disabled", t) } #T = null; #M = {}; #ts = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [zi.#L], this.#T.append(document.importNode(zi.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t; this.#T.addEventListener("pointerdown", t => this.#pt(t)) } connectedCallback() { "x-numberinput" === this.parentElement.localName && (this.#ts = this.parentElement, this.#ts.setAttribute("hasstepper", "")) } disconnectedCallback() { this.#ts && (null === this.#ts.querySelector(":scope > x-stepper") && this.#ts.removeAttribute("hasstepper", ""), this.#ts = null) } attributeChangedCallback(t) { "disabled" === t && this.#Ot() } #Ot() { this.hasAttribute("disabled") && (this.removeAttribute("pressed"), this.#M["increment-button"].removeAttribute("data-pressed"), this.#M["decrement-button"].removeAttribute("data-pressed")) } #pt(s) { let r = s.target.closest(".button"), n = null; if (r === this.#M["increment-button"] ? n = "increment" : r === this.#M["decrement-button"] && (n = "decrement"), !(1 < s.buttons || null === n)) { { let i = Date.now(); r.setAttribute("data-pressed", ""), this.setAttribute("pressed", n), this.setPointerCapture(s.pointerId), this.addEventListener("pointerup", async t => { var e = Date.now() - i; e < 100 && await Se(100 - e), r.removeAttribute("data-pressed"), this.removeAttribute("pressed") }, { once: !0 }) } { let e = null, t = Date.now(), i = s["shiftKey"]; this.dispatchEvent(new CustomEvent(n + "start", { bubbles: !0 })), this.dispatchEvent(new CustomEvent(n, { bubbles: !0, detail: { shiftKey: i } })), this.addEventListener("pointerup", t => { clearInterval(e), this.dispatchEvent(new CustomEvent(n + "end", { bubbles: !0 })) }, { once: !0 }), e = setInterval(() => { 500 < Date.now() - t && this.dispatchEvent(new CustomEvent(n, { bubbles: !0, detail: { shiftKey: i } })) }, 100) } } } } customElements.define("x-stepper", zi); class Ci extends HTMLElement { static observedAttributes = ["value", "size"]; static #A = Mt`<template><div id="preview"></div></template>`; static #L = Tt`:host{display:block;width:18px;height:18px;cursor:default;box-sizing:border-box;overflow:hidden}#preview{width:100%;height:100%;position:relative}`; get value() { return this.hasAttribute("value") ? this.getAttribute("value") : "white" } set value(t) { this.setAttribute("value", t) } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } #T = null; #M = {}; #D = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [Ci.#L], this.#T.append(document.importNode(Ci.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t } connectedCallback() { this.#es(), this.#F(), Me.addEventListener("sizechange", this.#D = () => this.#F()) } disconnectedCallback() { Me.removeEventListener("sizechange", this.#D) } attributeChangedCallback(t) { "value" === t ? this.#es() : "size" === t && this.#F() } #es() { this.#M.preview.style.background = this.value } #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } } customElements.define("x-swatch", Ci); class Si extends HTMLElement { static observedAttributes = ["toggled", "disabled", "size"]; static #A = Mt`<template><main id="main"><div id="indicator" part="indicator"><div id="indicator-track" part="indicator-track"><div id="indicator-thumb" part="indicator-thumb"></div></div></div><div id="description"><slot></slot></div></main></template>`; static #L = Tt`:host{display:block;width:fit-content;margin:2px 0}:host([disabled]){opacity:.4;pointer-events:none}#main{display:flex;align-items:center}#indicator{position:relative;width:34px;height:15px;display:flex;align-items:center}#indicator-track{display:flex;align-items:center;width:100%;height:65%;background:currentColor;border-radius:999px}#indicator-thumb{position:absolute;left:0;width:16px;height:16px;background:currentColor;border-radius:999px;transition:left .2s cubic-bezier(.4, 0, .2, 1)}:host([toggled]) #indicator-thumb{left:calc(100% - 16px)}:host([mixed]) #indicator-thumb{left:calc(50% - 16px / 2)}#description{flex:1}`; get toggled() { return this.hasAttribute("toggled") } set toggled(t) { t ? this.setAttribute("toggled", "") : this.removeAttribute("toggled") } get mixed() { return this.hasAttribute("mixed") } set mixed(t) { t ? this.setAttribute("mixed", "") : this.removeAttribute("mixed") } get disabled() { return this.hasAttribute("disabled") } set disabled(t) { t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled") } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } #T = null; #M = {}; #ct = 0; #D = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [Si.#L], this.#T.append(document.importNode(Si.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t; this.addEventListener("pointerdown", t => this.#pt(t)), this.addEventListener("click", t => this.#I(t)), this.addEventListener("keydown", t => this.#bt(t)) } connectedCallback() { Me.addEventListener("sizechange", this.#D = () => this.#F()), this.#xt(), this.#F() } disconnectedCallback() { Me.removeEventListener("sizechange", this.#D) } attributeChangedCallback(t) { "toggled" === t ? this.#It() : "disabled" === t ? this.#Ot() : "size" === t && this.#F() } #xt() { this.setAttribute("role", "switch"), this.setAttribute("aria-checked", this.mixed ? "mixed" : this.toggled), this.setAttribute("aria-disabled", this.disabled), this.disabled ? (this.#ct = 0 < this.tabIndex ? this.tabIndex : 0, this.tabIndex = -1) : (this.tabIndex < 0 && (this.tabIndex = 0 < this.#ct ? this.#ct : 0), this.#ct = 0) } #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } #It() { this.setAttribute("aria-checked", this.mixed ? "mixed" : this.toggled) } #Ot() { this.#xt() } #pt(e) { if (1 < e.buttons) e.preventDefault(); else if (!1 === this.matches(":focus")) { e.preventDefault(); let t = Ne(this.parentNode, "[tabindex]"); t && t.focus() } } async#I(t) { this.mixed ? this.mixed = !1 : this.toggled = !this.toggled, this.dispatchEvent(new CustomEvent("toggle")) } #bt(t) { "Enter" !== t.code && "Space" !== t.code || (t.preventDefault(), this.click()) } } customElements.define("x-switch", Si); let Ei = Math["max"]; class Ai extends HTMLElement { static observedAttributes = ["selected", "disabled", "size"]; static #A = Mt`<template><div id="ripples"></div><div id="selection-indicator" part="selection-indicator"></div><div id="content"><slot></slot></div></template>`; static #L = Tt`:host{position:relative;display:flex;align-items:center;justify-content:center;min-height:30px;padding:2px 12px;box-sizing:border-box;cursor:default;user-select:none;box-sizing:border-box;font-size:14px;--trigger-effect:none}:host(:focus){z-index:10;outline:0}#content{display:inherit;flex-flow:inherit;align-items:inherit;z-index:100}#ripples{position:absolute;z-index:0;top:0;left:0;width:100%;height:100%;overflow:hidden;pointer-events:none}#ripples .ripple{position:absolute;top:0;left:0;width:200px;height:200px;background:currentColor;opacity:.2;border-radius:999px;transform:none;transition:all .8s cubic-bezier(.4, 0, .2, 1);will-change:opacity,transform;pointer-events:none}#selection-indicator{display:none;width:100%;height:0;background:var(--accent-color);position:absolute;bottom:0;left:0}:host([selected]) #selection-indicator{display:block}`; get value() { return this.hasAttribute("value") ? this.getAttribute("value") : "" } set value(t) { this.setAttribute("value", t) } get selected() { return this.hasAttribute("selected") } set selected(t) { t ? this.setAttribute("selected", "") : this.removeAttribute("selected") } get disabled() { return this.hasAttribute("disabled") } set disabled(t) { t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled") } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } #T = null; #M = {}; #D = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [Ai.#L], this.#T.append(document.importNode(Ai.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t; this.addEventListener("pointerdown", t => this.#pt(t)), this.addEventListener("click", t => this.#I(t)) } connectedCallback() { this.#xt(), this.#F(), Me.addEventListener("sizechange", this.#D = () => this.#F()) } disconnectedCallback() { Me.removeEventListener("sizechange", this.#D) } attributeChangedCallback(t) { "selected" === t || "disabled" === t ? this.#xt() : "size" === t && this.#F() } animateSelectionIndicator(s) { return new Promise(async t => { var e, i; "0px" !== this.#M["selection-indicator"].style.height && (e = this.getBoundingClientRect(), i = s.getBoundingClientRect(), await this.#M["selection-indicator"].animate([{ left: "0px", width: e.width + "px" }, { left: i.left - e.left + "px", width: i.width + "px" }], { duration: 100, iterations: 1, delay: 0, easing: "cubic-bezier(0.4, 0.0, 0.2, 1)" }).finished), t() }) } #xt() { this.setAttribute("role", "tab"), this.setAttribute("aria-selected", this.selected), this.setAttribute("aria-disabled", this.disabled), this.setAttribute("tabindex", this.selected ? "0" : "-1") } #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } async#pt(a) { if (!1 === this.matches(":focus")) { a.preventDefault(); let t = Ne(this.parentNode, "[tabindex]"); t && t.focus() } if (!(1 < a.buttons)) { { let i = Date.now(); this.setAttribute("pressed", ""), this.setPointerCapture(a.pointerId), this.addEventListener("pointerup", async t => { var e; !0 === this.selected && (e = Date.now() - i) < 100 && await Se(100 - e), this.removeAttribute("pressed") }, { once: !0 }) } if ("ripple" === getComputedStyle(this).getPropertyValue("--trigger-effect").trim()) { let t = this.#M.ripples.getBoundingClientRect(), e = 1.5 * Ei(t.width, t.height), i = a.clientY - t.y - e / 2, s = a.clientX - t.x - e / 2, r = new Promise(t => this.addEventListener("pointerup", t, { once: !0 })), n = Be("div"); n.setAttribute("part", "ripple"), n.setAttribute("class", "ripple pointer-down-ripple"), n.setAttribute("style", `width: ${e}px; height: ${e}px; top: ${i}px; left: ${s}px;`), this.#M.ripples.append(n), this.setPointerCapture(a.pointerId), n.hidden = !0, await Se(10), n.hidden = !1; a = n.animate({ transform: ["scale(0)", "scale(1)"] }, { duration: 300, easing: "cubic-bezier(0.4, 0, 0.2, 1)" }), a = (await r, await a.finished, getComputedStyle(n).opacity); await n.animate({ opacity: [a, "0"] }, { duration: 300, easing: "cubic-bezier(0.4, 0, 0.2, 1)" }).finished, n.remove() } } } async#I(t) { if (null === this.#M.ripples.querySelector(".pointer-down-ripple") && "ripple" === getComputedStyle(this).getPropertyValue("--trigger-effect").trim()) { let t = this.#M.ripples.getBoundingClientRect(), e = 1.5 * Ei(t.width, t.height), i = t.y + t.height / 2 - t.y - e / 2, s = t.x + t.width / 2 - t.x - e / 2, r = Be("div"); r.setAttribute("part", "ripple"), r.setAttribute("class", "ripple click-ripple"), r.setAttribute("style", `width: ${e}px; height: ${e}px; top: ${i}px; left: ${s}px;`), this.#M.ripples.append(r); await r.animate({ transform: ["scale(0)", "scale(1)"] }, { duration: 300, easing: "cubic-bezier(0.4, 0, 0.2, 1)" }).finished; var n = getComputedStyle(r).opacity; await r.animate({ opacity: [n, "0"] }, { duration: 300, easing: "cubic-bezier(0.4, 0, 0.2, 1)" }).finished, r.remove() } } } customElements.define("x-tab", Ai); class Li extends HTMLElement { static #A = Mt`<template><slot></slot></template>`; static #L = Tt`:host{position:relative;display:flex;margin:0 auto;width:fit-content;max-width:100%;box-sizing:border-box;justify-content:center}::slotted(x-tab){flex:0}`; get value() { var t = this.querySelector("x-tab[selected]"); return t ? t.value : null } set value(e) { let t = [...this.querySelectorAll("x-tab")], i = null === e ? null : t.find(t => t.value === e); for (var s of t) s.selected = s === i } #T = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [Li.#L], this.#T.append(document.importNode(Li.#A.content, !0)), this.addEventListener("click", t => this.#I(t)), this.addEventListener("keydown", t => this.#bt(t)) } connectedCallback() { this.setAttribute("role", "tablist") } async#I(s) { if (!(1 < s.buttons) && s.target.closest("x-tab")) { let t = this.querySelectorAll("x-tab"), e = s.target.closest("x-tab"), i = this.querySelector("x-tab[selected]"); if (e !== i) { i && await i.animateSelectionIndicator(e); for (var r of t) r.selected = r === e; this.dispatchEvent(new CustomEvent("change", { bubbles: !0 })) } } } #bt(e) { if ("Enter" === e.code || "Space" === e.code) { let t = e.target; t.querySelector("x-label"), e.preventDefault(), t.click() } else if ("ArrowLeft" === e.code) { let i = [...this.querySelectorAll("x-tab:not([disabled])")], s = this.querySelector('x-tab[tabindex="0"]'); if (e.target, e.preventDefault(), s && 0 < i.length) { let t = i.indexOf(s), e = i[t - 1] || i[i.length - 1]; s.tabIndex = -1, e.tabIndex = 0, e.focus() } } else if ("ArrowRight" === e.code) { let i = [...this.querySelectorAll("x-tab:not([disabled])")], s = this.querySelector('x-tab[tabindex="0"]'); if (e.target, e.preventDefault(), s && 0 < i.length) { let t = i.indexOf(s), e = i[t + 1] || i[0]; s.tabIndex = -1, e.tabIndex = 0, e.focus() } } } } customElements.define("x-tabs", Li); class Mi extends HTMLElement { static observedAttributes = ["disabled", "size"]; static #A = Mt`<template><div id="container"><div id="scope" part="scope"><slot id="scope-slot" name="scope"></slot></div><main id="main" part="main"><slot></slot><svg id="remove-button" part="remove-button" viewBox="0 0 100 100"><path id="remove-button-path"></path></svg></main></div></template>`; static #L = Tt`:host{display:inline-block;height:25px;box-sizing:border-box;overflow:hidden;color:var(--text-color);border-width:1px;border-style:solid}:host([toggled]){background:gray;color:#fff;outline:0}:host([disabled]){opacity:.5}:host([hidden]){display:none}:host(:focus){outline:0}#container{width:100%;height:100%;display:flex;align-items:center;justify-content:center}#scope{height:100%;padding:0 6px;display:none;align-items:center;justify-content:center;border-right-width:1px;border-right-style:solid}:host([scoped]) #scope{display:flex}#main{height:100%;padding:0 6px;display:flex;align-items:center;justify-content:center}#remove-button{display:none;opacity:.8;width:12px;height:12px;vertical-align:middle;margin-left:4px;d:path("M 25 16 L 50 41 L 75 16 L 84 25 L 59 50 L 84 75 L 75 84 L 50 59 L 25 84 L 16 75 L 41 50 L 16 25 Z");fill:currentColor;color:inherit}:host([removable]) #remove-button{display:block}#remove-button:hover{background:rgba(0,0,0,.1);opacity:1}#remove-button path{d:inherit;fill:inherit;pointer-events:none}`; get value() { return this.hasAttribute("value") ? this.getAttribute("value") : null } set value(t) { null === t ? this.removeAttribute("value") : this.setAttribute("value", t) } get removable() { return this.hasAttribute("removable") } set removable(t) { t ? this.setAttribute("removable", "") : this.removeAttribute("removable") } get toggled() { return this.hasAttribute("toggled") } set toggled(t) { t ? this.setAttribute("toggled", "") : this.removeAttribute("toggled") } get disabled() { return this.hasAttribute("disabled") } set disabled(t) { t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled") } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } #T = null; #M = {}; #D = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [Mi.#L], this.#T.append(document.importNode(Mi.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t; this.#M["scope-slot"].addEventListener("slotchange", () => this.#is()), this.#M["remove-button"].addEventListener("click", t => this.#ss(t)) } connectedCallback() { this.#F(), this.#is(), Me.addEventListener("sizechange", this.#D = () => this.#F()), this.closest("x-tags") ? (this.tabIndex = 0, this.removable = !1) : this.closest("x-tagsinput") ? (this.toggled = !1, this.tabIndex = 0, this.removable = !0) : this.removable = !1 } disconnectedCallback() { Me.removeEventListener("sizechange", this.#D) } attributeChangedCallback(t) { "size" === t && this.#F() } #ss(t) { t.buttons <= 1 && this.dispatchEvent(new CustomEvent("remove", { bubbles: !0 })) } #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } #is() { 0 === this.#M["scope-slot"].assignedElements().length ? this.removeAttribute("scoped") : this.setAttribute("scoped", "") } } customElements.define("x-tag", Mi); class Ti extends HTMLElement { static #A = Mt`<template><slot></slot></template>`; static #L = Tt`:host{display:flex;box-sizing:border-box;align-items:center;justify-content:flex-start}:host([hidden]){display:none}`; get value() { return [...this.children].filter(t => "x-tag" === t.localName).filter(t => t.toggled).map(t => t.value).filter(t => null !== t) } set value(t) { var e; for (e of [...this.children].filter(t => "x-tag" === t.localName)) e.toggled = t.includes(e.value) } #T = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [Ti.#L], this.#T.append(document.importNode(Ti.#A.content, !0)), this.addEventListener("pointerdown", t => this.#pt(t)), this.addEventListener("click", t => this.#I(t)), this.addEventListener("keydown", t => this.#bt(t)) } #pt(t) { if (1 < t.buttons) t.preventDefault(); else if (t.preventDefault(), !1 === this.matches(":focus")) { let t = Ne(this.parentNode, "*[tabindex]:not(a)"); this.addEventListener("pointerup", () => { t ? t.focus() : this.blur() }, { once: !0 }) } } #I(t) { let e = t.target.closest("x-tag"); e && !1 === t.defaultPrevented && (e.toggled = !e.toggled, this.dispatchEvent(new CustomEvent("toggle", { detail: e }))) } #bt(e) { if (!1 === e.defaultPrevented) if ("Enter" === e.code || "Space" === e.code) { let t = this.querySelector("x-tag:focus"); t && (e.preventDefault(), t.click()) } else if ("ArrowRight" === e.key) { let t = this.querySelector("x-tag:focus"); t && (t.nextElementSibling ? t.nextElementSibling.focus() : t !== t.parentElement.firstElementChild && t.parentElement.firstElementChild.focus()) } else if ("ArrowLeft" === e.key) { let t = this.querySelector("x-tag:focus"); t && (t.previousElementSibling ? t.previousElementSibling.focus() : t !== t.parentElement.lastElementChild && t.parentElement.lastElementChild.focus()) } } } customElements.define("x-tags", Ti); class $i extends HTMLElement { static observedAttributes = ["spellcheck", "disabled", "size"]; static #A = Mt`<template><main id="main"><div id="tags"><slot></slot><span id="input" part="input" spellcheck="false" tabindex="0"></span></div></main><x-popover id="suggestions-popover" part="suggestions"><div id="suggested-tags"></div></x-popover></template>`; static #L = Tt`:host{display:block;position:relative;min-height:29px;font-size:12px}:host(:focus){z-index:10}:host([disabled]){pointer-events:none;opacity:.5}:host([hidden]){display:none}::selection{color:var(--selection-color);background-color:var(--selection-background-color)}#main{width:100%;height:100%;cursor:text}#tags{display:flex;flex-wrap:wrap}:host([mixed]) #tags{opacity:.7}#input{align-items:center;justify-content:flex-start;height:25px;margin:2px;padding:0 3px 0 6px;box-sizing:border-box;line-height:25px;color:inherit;outline:0;white-space:pre;cursor:text;user-select:text;pointer-events:none}#input[contenteditable]:focus{flex-grow:1;pointer-events:all}#suggestions-popover{width:200px;max-height:200px;padding:4px;box-sizing:border-box}#suggestions-popover #suggested-tags{flex:1;overflow:auto}#suggestions-popover x-tag{display:block;margin:4px 0 0 0}#suggestions-popover x-tag:first-child{margin-top:0}`; get value() { return [...this.children].filter(t => "x-tag" === t.localName).map(t => t.value).filter(t => null !== t) } get delimiter() { return this.hasAttribute("delimiter") ? this.getAttribute("delimiter") : "," } set delimiter(t) { this.setAttribute("delimiter", t) } get spellcheck() { return this.hasAttribute("spellcheck") } set spellcheck(t) { t ? this.setAttribute("spellcheck", "") : this.removeAttribute("spellcheck") } get mixed() { return this.hasAttribute("mixed") } set mixed(t) { t ? this.setAttribute("mixed", "") : this.removeAttribute("mixed") } get disabled() { return this.hasAttribute("disabled") } set disabled(t) { t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled") } get suggestions() { return this.hasAttribute("suggestions") } set suggestions(t) { t ? this.setAttribute("suggestions", "") : this.removeAttribute("suggestions") } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } #T = null; #M = {}; #ct = 0; #D = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed", delegatesFocus: !0 }), this.#T.adoptedStyleSheets = [Me.themeStyleSheet, $i.#L], this.#T.append(document.importNode($i.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t; this.#M.input.addEventListener("focusin", t => this.#ns(t)), this.#M.input.addEventListener("focusout", t => this.#os(t)), this.#T.addEventListener("pointerdown", t => this.#ri(t)), this.#T.addEventListener("remove", t => this.#ss(t)), this.#T.addEventListener("keydown", t => this.#bt(t)), this.#M.input.addEventListener("input", t => this.#ie(t)) } connectedCallback() { this.#rs(), this.#xt(), this.#F(), Me.addEventListener("sizechange", this.#D = () => this.#F()) } disconnectedCallback() { Me.removeEventListener("sizechange", this.#D) } attributeChangedCallback(t, e, i) { e !== i && ("spellcheck" === t ? this.#oe() : "disabled" === t ? this.#Ot() : "size" === t && this.#tt()) } clear() { var t = [...this.children].filter(t => "x-tag" === t.localName); if (0 < t.length) { for (var e of t) e.remove(), this.dispatchEvent(new CustomEvent("remove", { detail: e })); this.#hs(), this.#rs(), this.dispatchEvent(new CustomEvent("change")) } } getSuggestions(t) { return [] } #as() { let t = new Range, e = (t.selectNodeContents(this.#M.input), t.getBoundingClientRect()); return 0 === e.x && 0 === e.width && ((e = this.#M.input.getBoundingClientRect()).width = 20), e } #ls() { let e = this.#M.input.textContent.trim(); if (this.#M.input.textContent = "", 0 < e.length && !1 === this.value.includes(e)) { let t; var i, s; t = e.includes(":") ? ([i, s] = e.split(":").map(t => t.trim()), Mt`<x-tag class="tag" value="${e}" removable><x-label slot="scope">${i}</x-label><x-label>${s}</x-label></x-tag>`) : Mt`<x-tag class="tag" value="${e}" removable><x-label>${e}</x-label></x-tag>`, this.append(t), this.#hs(), this.#rs(), this.dispatchEvent(new CustomEvent("add", { detail: t })), this.dispatchEvent(new CustomEvent("change")) } } #ri(t) { var e; t.target === this.#M.main || t.target === this.#M.tags ? (t.preventDefault(), this.#M.input.setAttribute("contenteditable", ""), this.#ds()) : t.target === this.#M.input ? (this.#M.input.setAttribute("contenteditable", ""), this.#hs()) : t.target.closest("x-popover") ? (t.preventDefault(), (e = t.target.closest("x-tag")) && (this.#M.input.textContent = "", this.#M["suggestions-popover"].close(), this.append(e), this.dispatchEvent(new CustomEvent("add", { detail: e })), this.dispatchEvent(new CustomEvent("change")))) : t.target.closest("x-tag") && (this.#M.input.focus(), this.#ls()) } #ss(t) { t.stopPropagation(); let e = t.target; e.remove(), this.#rs(), this.dispatchEvent(new CustomEvent("remove", { detail: e })), this.dispatchEvent(new CustomEvent("change")) } #oe() { this.#M.input.spellcheck = this.spellcheck } #Ot() { this.#xt() } #tt() { this.#F() } async#ns() { this.#M.input.setAttribute("contenteditable", ""), this.dispatchEvent(new CustomEvent("textinputmodestart", { bubbles: !0, composed: !0 })), await Se(10), this.#M.input.matches(":focus") && (this.#ds(), this.#hs()) } #os() { this.#ls(), this.#M.input.removeAttribute("contenteditable"), this.dispatchEvent(new CustomEvent("textinputmodeend", { bubbles: !0, composed: !0 })), this.#M["suggestions-popover"].close() } #ie(t) { this.#M.input.textContent.includes(this.delimiter) && this.#ls(), this.#rs(), this.dispatchEvent(new CustomEvent("input")), this.#hs(t.inputType) } #bt(n) { if ("Enter" === n.key) n.target === this.#M.input && (n.preventDefault(), this.#ls()); else if ("Backspace" === n.key) { if (n.target === this.#M.input) { if (0 === this.#M.input.textContent.length) { let t = [...this.children].filter(t => "x-tag" === t.localName), e = t[t.length - 1] || null; e && (e.remove(), this.#hs(), this.#rs(), this.dispatchEvent(new CustomEvent("remove", { detail: e })), this.dispatchEvent(new CustomEvent("change"))) } } else if ("x-tag" === n.target.localName) { let t = [...this.children].filter(t => "x-tag" === t.localName), e = n.target, i = t.indexOf(e), s = t[i + 1] || null, r = t[i - 1] || null; (s || r || this.#M.input).focus(), e.remove(), this.#rs(), this.dispatchEvent(new CustomEvent("remove", { detail: e })), this.dispatchEvent(new CustomEvent("change")) } } else if ("ArrowDown" === n.key) { if (this.#M["suggestions-popover"].opened) { let i = [...this.#M["suggested-tags"].children]; if (1 < i.length) { n.preventDefault(); let e = null; { let t = i.find(t => t.toggled); e = t ? (t.toggled = !1, s = i.indexOf(t), i[s + 1] || i[0]) : i[0] } e.toggled = !0, e.scrollIntoViewIfNeeded(); var s = this.#T.getSelection().getRangeAt(0).startOffset, t = e.querySelector("x-label").textContent; this.#M.input.textContent = t, this.#ds(s, t.length) } } } else if ("ArrowUp" === n.key && this.#M["suggestions-popover"].opened) { let i = [...this.#M["suggested-tags"].children]; if (1 < i.length) { n.preventDefault(); let e = null; { let t = i.find(t => t.toggled); e = t ? (t.toggled = !1, s = i.indexOf(t), i[s - 1] || i[i.length - 1]) : i[i.length - 1] } e.toggled = !0, e.scrollIntoViewIfNeeded(); t = this.#T.getSelection().getRangeAt(0).startOffset, n = e.querySelector("x-label").textContent; this.#M.input.textContent = n, this.#ds(t, n.length) } } } #J() { this.#rs() } #rs() { let t = this.querySelector(":scope > x-label"); t && (t.hidden = 0 < this.value.length || 0 < this.#M.input.textContent.length) } #xt() { this.setAttribute("role", "input"), this.setAttribute("aria-disabled", this.disabled), this.disabled ? (this.#ct = 0 < this.tabIndex ? this.tabIndex : 0, this.tabIndex = -1) : (this.tabIndex < 0 && (this.tabIndex = 0 < this.#ct ? this.#ct : 0), this.#ct = 0) } #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } #ds(t = 0, e = this.#M.input.textContent.length) { let i = new Range, s = (0 === t && e === this.#M.input.textContent.length ? i.selectNodeContents(this.#M.input) : (i.setStart(this.#M.input.firstChild, t), i.setEnd(this.#M.input.firstChild, e)), window.getSelection()); s.removeAllRanges(), s.addRange(i) } #hs(i = "insertText") { if (this.suggestions) { let t = this.#M.input.textContent, e = this.#T.getSelection().getRangeAt(0), s = (!1 === e.collapsed && (t = t.substring(0, e.startOffset)), this.getSuggestions(t)); if (0 < s.length && "deleteContentBackward" !== i) { let t = this.#M.input.textContent, e = s[0].querySelector("x-label").textContent, i = this.#M.input.firstChild; i && (i.textContent = e, this.#ds(t.length, e.length)) } var r; 0 === s.length ? !(this.#M["suggested-tags"].innerHTML = "") === this.#M["suggestions-popover"].opened && this.#M["suggestions-popover"].close() : (r = this.#as(), this.#M["suggested-tags"].innerHTML = "", this.#M["suggested-tags"].append(...s), "deleteContentBackward" !== i && 0 < t.length && (s[0].toggled = !0), !1 !== this.#M["suggestions-popover"].opened && this.#M["suggestions-popover"].close(!1), this.#M["suggestions-popover"].open(r), this.#M["suggested-tags"].scrollTop = 0) } } } customElements.define("x-tagsinput", $i); class Di extends HTMLElement { static observedAttributes = ["value", "spellcheck", "disabled", "validation", "size"]; static #A = Mt`<template><main id="main"><slot></slot><div id="editor" contenteditable="plaintext-only" spellcheck="false"></div></main></template>`; static #L = Tt`:host{display:block;position:relative;width:100%;min-height:100px;box-sizing:border-box;background:#fff;font-size:12.5px;overflow:auto}:host(:hover){cursor:text}:host([mixed]){color:rgba(0,0,0,.7)}:host([disabled]){pointer-events:none;opacity:.5}:host([hidden]){display:none}::selection{color:var(--selection-color);background-color:var(--selection-background-color)}:host([error]) ::selection{color:#fff;background-color:#d50000}::-webkit-scrollbar{max-width:6px;max-height:6px;background:0 0}::-webkit-scrollbar-track{border-radius:25px}::-webkit-scrollbar-thumb{background-color:rgba(0,0,0,.2);border-radius:25px}::-webkit-scrollbar-corner{display:none}#main{display:flex;flex-flow:column;width:100%;min-height:100%}#editor{flex:1;padding:2px 6px;box-sizing:border-box;color:inherit;background:0 0;border:none;outline:0;font-family:inherit;font-size:inherit}`; get value() { return this.#M.editor.textContent } set value(t) { this.#M.editor.textContent = t, "instant" === this.validation ? this.reportValidity() : "auto" !== this.validation && "manual" !== this.validation || (this.#_t || this.#Jt) && this.reportValidity(), this.#Qt() } get spellcheck() { return this.hasAttribute("spellcheck") } set spellcheck(t) { t ? this.setAttribute("spellcheck", "") : this.removeAttribute("spellcheck") } get minLength() { return this.hasAttribute("minlength") ? parseInt(this.getAttribute("minlength")) : 0 } set minLength(t) { this.setAttribute("minlength", t) } get maxLength() { return this.hasAttribute("maxlength") ? parseInt(this.getAttribute("maxlength")) : 1 / 0 } set maxLength(t) { this.setAttribute("maxlength", t) } get required() { return this.hasAttribute("required") } set required(t) { t ? this.setAttribute("required", "") : this.removeAttribute("required") } get mixed() { return this.hasAttribute("mixed") } set mixed(t) { t ? this.setAttribute("mixed", "") : this.removeAttribute("mixed") } get disabled() { return this.hasAttribute("disabled") } set disabled(t) { t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled") } get validation() { return this.hasAttribute("validation") ? this.getAttribute("validation") : "auto" } set validation(t) { this.setAttribute("validation", t) } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } get empty() { return this.hasAttribute("empty") } get error() { return this.hasAttribute("error") } #T = null; #M = {}; #us = ""; #ct = 0; #_t = null; #Jt = null; #D = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed", delegatesFocus: !0 }), this.#T.adoptedStyleSheets = [Di.#L], this.#T.append(document.importNode(Di.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t; this.addEventListener("click", t => this.#I(t)), this.addEventListener("focusin", t => this.#te(t)), this.addEventListener("focusout", t => this.#ee(t)), this.#M.editor.addEventListener("click", t => this.#cs(t)), this.#M.editor.addEventListener("input", t => this.#ai(t)) } connectedCallback() { this.#xt(), this.#F(), this.#Qt(), "instant" === this.validation ? this.reportValidity() : "auto" !== this.validation && "manual" !== this.validation || (this.#_t || this.#Jt) && this.reportValidity(), Me.addEventListener("sizechange", this.#D = () => this.#F()) } disconnectedCallback() { Me.removeEventListener("sizechange", this.#D) } attributeChangedCallback(t) { "value" === t ? this.#Q() : "spellcheck" === t ? this.#oe() : "disabled" === t ? this.#Ot() : "validation" === t ? this.#ae() : "size" === t && this.#tt() } reportValidity() { var t = new CustomEvent("beforevalidate", { bubbles: !1, cancelable: !0 }); return this.dispatchEvent(t), !1 === t.defaultPrevented && (this.value.length < this.minLength ? this.#_t = { href: "#entered-text-is-too-short" } : this.value.length > this.maxLength ? this.#_t = { href: "#entered-text-is-too-long" } : this.required && 0 === this.value.length ? this.#_t = { href: "#required-field" } : this.#_t = null, this.#de()), null === this.#_t && null === this.#Jt } setCustomValidity(t) { this.#Jt = "" === t ? null : t, this.#de() } #de() { var e, i = this.#Jt || this.#_t; i ? this.setAttribute("error", "") : this.removeAttribute("error"); { let t = this.querySelector(':scope > x-tooltip[type="error"]'); i && this.matches(":focus") ? (t || ((t = Be("x-tooltip")).setAttribute("type", "error"), this.append(t)), i.href ? (e = i.args ? Object.entries(i.args).map(([t, e]) => t + ":" + e).join(",") : "", t.innerHTML = `<x-message href="${i.href}" args="${e}"></x-message>`) : t.innerHTML = i, Se(10).then(() => { t.open(this) })) : t && t.close().then(() => t.remove()) } } #Qt() { 0 === this.value.length ? this.setAttribute("empty", "") : this.removeAttribute("empty") } #xt() { this.setAttribute("role", "input"), this.setAttribute("aria-disabled", this.disabled), this.disabled ? (this.#ct = 0 < this.tabIndex ? this.tabIndex : 0, this.tabIndex = -1) : (this.tabIndex < 0 && (this.tabIndex = 0 < this.#ct ? this.#ct : 0), this.#ct = 0) } #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } #Q() { this.value = this.hasAttribute("value") ? this.getAttribute("value") : "", this.matches(":focus") && document.execCommand("selectAll") } #oe() { this.#M.editor.spellcheck = this.spellcheck } #Ot() { this.#M.editor.disabled = this.disabled, this.#xt() } #ae() { "instant" === this.validation ? this.reportValidity() : "auto" !== this.validation && "manual" !== this.validation || (this.#_t || this.#Jt) && this.reportValidity() } #tt() { this.#F() } #I() { this.#de() } #te() { this.#us = this.value, this.#de(), this.dispatchEvent(new CustomEvent("textinputmodestart", { bubbles: !0, composed: !0 })) } #ee() { this.dispatchEvent(new CustomEvent("textinputmodeend", { bubbles: !0, composed: !0 })), this.#T.getSelection().collapse(this.#M.main), "auto" === this.validation || "instant" === this.validation ? this.reportValidity() : "manual" === this.validation && this.#de(), null !== (this.#_t || this.#Jt) || this.value === this.#us && !this.mixed || (this.mixed = !1, this.dispatchEvent(new CustomEvent("change", { bubbles: !0 }))) } #cs(t) { 4 <= t.detail && document.execCommand("selectAll") } #ai(t) { this.dispatchEvent(new CustomEvent("input", { bubbles: !0 })), this.#Qt(), "instant" === this.validation ? this.reportValidity() : "auto" !== this.validation && "manual" !== this.validation || (this.#_t || this.#Jt) && this.reportValidity() } } customElements.define("x-texteditor", Di); class Ri extends HTMLElement { static observedAttributes = ["type", "size"]; static #ps = Mt`<template><svg data-type="ring" viewBox="0 0 100 100"><ellipse ry="40" rx="40" cy="50" cx="50" stroke-width="10"/></svg></template>`; static #ms = Mt`<template><svg data-type="spin" viewBox="0 0 100 100"><rect transform="rotate(  0 50 50) translate(0 -38)"></rect><rect transform="rotate( 30 50 50) translate(0 -38)"></rect><rect transform="rotate( 60 50 50) translate(0 -38)"></rect><rect transform="rotate( 90 50 50) translate(0 -38)"></rect><rect transform="rotate(120 50 50) translate(0 -38)"></rect><rect transform="rotate(150 50 50) translate(0 -38)"></rect><rect transform="rotate(180 50 50) translate(0 -38)"></rect><rect transform="rotate(210 50 50) translate(0 -38)"></rect><rect transform="rotate(240 50 50) translate(0 -38)"></rect><rect transform="rotate(270 50 50) translate(0 -38)"></rect><rect transform="rotate(300 50 50) translate(0 -38)"></rect><rect transform="rotate(330 50 50) translate(0 -38)"></rect></svg></template>`; static #L = Tt`:host{display:block;width:30px;height:30px;box-sizing:border-box}:host([hidden]){display:none}:host([type=ring]){color:#4285f4}:host([type=spin]){color:#404040}svg{color:inherit;width:100%;height:100%}svg[data-type=ring] ellipse{fill:none;stroke:currentColor;stroke-linecap:round;stroke-dasharray:10,1000;animation:ring-dash-animation 2s cubic-bezier(.8,.25,.25,.9) infinite,ring-rotate-animation 2s linear infinite;transform-origin:center}@keyframes ring-rotate-animation{to{transform:rotate(360deg)}}@keyframes ring-dash-animation{50%{stroke-dasharray:200;stroke-dashoffset:0}100%{stroke-dasharray:245;stroke-dashoffset:-260}}svg[data-type=spin] rect{x:46.5px;y:40px;width:7px;height:22px;rx:5px;ry:5px;fill:currentColor;animation-name:spin-animation;animation-duration:1s;animation-timing-function:linear;animation-iteration-count:infinite;animation-delay:0s}svg[data-type=spin] rect:first-child{animation-delay:calc(1s *  1/12)}svg[data-type=spin] rect:nth-child(2){animation-delay:calc(1s *  2/12)}svg[data-type=spin] rect:nth-child(3){animation-delay:calc(1s *  3/12)}svg[data-type=spin] rect:nth-child(4){animation-delay:calc(1s *  4/12)}svg[data-type=spin] rect:nth-child(5){animation-delay:calc(1s *  5/12)}svg[data-type=spin] rect:nth-child(6){animation-delay:calc(1s *  6/12)}svg[data-type=spin] rect:nth-child(7){animation-delay:calc(1s *  7/12)}svg[data-type=spin] rect:nth-child(8){animation-delay:calc(1s *  8/12)}svg[data-type=spin] rect:nth-child(9){animation-delay:calc(1s *  9/12)}svg[data-type=spin] rect:nth-child(10){animation-delay:calc(1s * 10/12)}svg[data-type=spin] rect:nth-child(11){animation-delay:calc(1s * 11/12)}svg[data-type=spin] rect:nth-child(12){animation-delay:calc(1s * 12/12)}@keyframes spin-animation{0%{opacity:1}100%{opacity:0}}`; get type() { return this.hasAttribute("type") ? this.getAttribute("type") : "ring" } set type(t) { this.setAttribute("type", t) } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } #T = null; #D = null; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [Ri.#L] } connectedCallback() { this.#J(), this.#F(), Me.addEventListener("sizechange", this.#D = () => this.#F()) } disconnectedCallback() { Me.removeEventListener("sizechange", this.#D) } attributeChangedCallback(t, e, i) { e !== i && ("type" === t ? this.#J() : "size" === t && this.#F()) } #J() { let t = this.#T.firstElementChild, e = "ring" === this.type ? Ri.#ps : Ri.#ms; null === t ? this.#T.append(document.importNode(e.content, !0)) : t.dataset.type !== this.type && t.replaceWith(document.importNode(e.content, !0)), !1 === this.hasAttribute("type") && this.setAttribute("type", this.type) } #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } } customElements.define("x-throbber", Ri); class Pi extends HTMLElement { static observedAttributes = ["disabled"]; static #A = Mt`<template><slot></slot></template>`; static #L = Tt`:host{display:none;bottom:-30px;position:fixed;padding:3px 10px;width:fit-content;height:fit-content;max-width:300px;box-sizing:border-box;pointer-events:none;border-width:1px;border-style:solid;font-size:12px;z-index:99999;--align:bottom;--whitespace:8px;--open-transition:0 opacity cubic-bezier(0.4, 0, 0.2, 1);--close-transition:0 opacity cubic-bezier(0.4, 0, 0.2, 1)}:host([animating]),:host([opened]){display:block}`; get type() { return this.hasAttribute("type") ? this.getAttribute("type") : "hint" } set type(t) { this.setAttribute("type", t) } get disabled() { return this.hasAttribute("disabled") } set disabled(t) { t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled") } get opened() { return this.hasAttribute("opened") } #T = null; #M = {}; #Si = null; #Ei; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [Pi.#L], this.#T.append(document.importNode(Pi.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t } attributeChangedCallback(t) { "disabled" === t && this.disabled && this.opened && this.close() } open(r, n = !0) { return new Promise(async t => { var e, i, s; !1 === this.opened && this.isConnected && (this.setAttribute("opened", ""), this.#Li(r), this.#Si = je(this), this.#Si && this.#Si.addEventListener("scroll", this.#Ei = () => { this.close() }, { once: !0 }), n && (e = getComputedStyle(this).getPropertyValue("--open-transition"), [e, i, s] = ii(e), "opacity" === e && await this.animate({ opacity: ["0", "1"] }, { duration: i, easing: s }).finished), this.dispatchEvent(new CustomEvent("open", { bubbles: !0, detail: this }))), t() }) } close(r = !0) { return new Promise(async t => { var e, i, s; !0 === this.opened && (this.removeAttribute("opened"), this.dispatchEvent(new CustomEvent("close", { bubbles: !0, detail: this })), this.#Si.removeEventListener("scroll", this.#Ei), r && (e = getComputedStyle(this).getPropertyValue("--close-transition"), [e, i, s] = ii(e), this.setAttribute("animating", ""), "opacity" === e && await this.animate({ opacity: ["1", "0"] }, { duration: i, easing: s }).finished), this.removeAttribute("animating")), t() }) } #Li(i) { var t = getComputedStyle(this).getPropertyValue("--align").trim(); parseInt(getComputedStyle(this).borderWidth); let s = parseInt(getComputedStyle(this).getPropertyValue("--whitespace")), n = 0, a = 0, o = null; this.style.maxWidth = null, this.style.maxHeight = null, this.style.left = "0px", this.style.top = "0px"; var l = r(this.getBoundingClientRect()); if (0 === l.top && 0 === l.left || (n = -l.left, a = -l.top), o = i instanceof DOMPoint ? new DOMRect(i.x, i.y, 0, 0) : i instanceof DOMRect ? i : i instanceof Element ? i.getBoundingClientRect() : new DOMRect, "bottom" === t || "top" === t) { var l = (t = !1) => { this.style.maxHeight = null; r(this.getBoundingClientRect()); let e, i = 0; return this.style.top = a + o.bottom + s + "px", e = r(this.getBoundingClientRect()), i = e.bottom + 8 - window.innerHeight, t && 0 < i && (t = e.height - i, i = 0, this.style.maxHeight = t + "px"), i }, i = (t = !1) => { this.style.maxHeight = null; let e = r(this.getBoundingClientRect()), i = 0; return this.style.top = a + o.top - s - e.height + "px", e = r(this.getBoundingClientRect()), i = -(e.top - 8), t && 0 < i && (t = e.height - i, i = 0, this.style.maxHeight = t + "px", this.style.top = a + o.top - s - t + "px"), i }, h = () => { this.style.maxWidth = null; var t = r(this.getBoundingClientRect()); return this.style.left = n + o.left + o.width / 2 - t.width / 2 + "px", [-((t = r(this.getBoundingClientRect())).left - 8), t.right + 8 - window.innerWidth] }, d = (t = !1) => { this.style.maxWidth = null; let e = r(this.getBoundingClientRect()), i = 0; return this.style.left = n + window.innerWidth - 8 - e.width + "px", e = r(this.getBoundingClientRect()), i = -(e.left - 8), t && 0 < i && (t = e.width - i, i = 0, this.style.maxWidth = t + "px", this.style.left = n + window.innerWidth - 8 - t + "px"), i }, u = (t = !1) => { this.style.maxWidth = null; r(this.getBoundingClientRect()); let e, i = 0; return this.style.left = n + 8 + "px", e = r(this.getBoundingClientRect()), i = e.right + 8 - window.innerWidth, t && 0 < i && (t = e.width - i, i = 0, this.style.maxWidth = t + "px"), i }; "bottom" === t ? 0 < (e = l()) && (0 < (c = i()) && (e < c ? l : i)(!0)) : "top" === t && 0 < (e = i()) && 0 < (c = l()) && (e < c ? i : l)(!0); { let [t, e] = h(); 0 < e ? 0 < (t = d()) && d(!0) : 0 < t && (0 < u() && u(!0)) } } else if ("right" === t || "left" === t) { var e = (t = !1) => { this.style.maxWidth = null; r(this.getBoundingClientRect()); let e, i = 0; return this.style.left = n + o.right + s + "px", e = r(this.getBoundingClientRect()), i = e.right + 8 - window.innerWidth, t && 0 < i && (t = e.width - i, i = 0, this.style.maxWidth = t + "px"), i }, c = (t = !1) => { this.style.maxWidth = null; let e = r(this.getBoundingClientRect()), i = 0; return this.style.left = n + o.left - s - e.width + "px", e = r(this.getBoundingClientRect()), i = -(e.left - 8), t && 0 < i && (t = e.width - i, i = 0, this.style.maxWidth = t + "px", this.style.left = n + o.left - s - t + "px"), i }, i = () => { this.style.maxHeight = null; var t = r(this.getBoundingClientRect()); return this.style.top = a + o.top + o.height / 2 - t.height / 2 + "px", [-((t = r(this.getBoundingClientRect())).top - 8), t.bottom + 8 - window.innerHeight] }, l = (t = !1) => { this.style.maxHeight = null; let e = r(this.getBoundingClientRect()), i = 0; return this.style.top = a + window.innerHeight - 8 - e.height + "px", e = r(this.getBoundingClientRect()), i = -(e.top - 8), t && 0 < i && (t = e.height - i, i = 0, this.style.maxHeight = t + "px", this.style.top = a + window.innerHeight - 8 - t + "px"), i }, h = (t = !1) => { this.style.maxHeight = null; r(this.getBoundingClientRect()); let e, i = 0; return this.style.top = a + 8 + "px", e = r(this.getBoundingClientRect()), i = e.bottom + 8 - window.innerHeight, t && 0 < i && (t = e.height - i, i = 0, this.style.maxHeight = t + "px"), i }; "right" === t ? 0 < (d = e()) && (0 < (u = c()) && (d < u ? e : c)(!0)) : "left" === t && 0 < (d = c()) && 0 < (u = e()) && (d < u ? c : e)(!0); { let [t, e] = i(); 0 < e ? 0 < (t = l()) && l(!0) : 0 < t && (0 < h() && h(!0)) } } } } customElements.define("x-tooltip", Pi); let { PI: Ii, sqrt: Oi, atan2: Fi, sin: Bi, cos: Ni, pow: ji } = Math; class Hi extends HTMLElement {
    static observedAttributes = ["value", "size"]; static #A = Mt`<template><x-box vertical><div id="huesat-slider" part="slider"><img id="huesat-image"><div id="huesat-marker"></div></div><div id="value-slider" part="slider"><div id="value-slider-track"><div id="value-slider-marker"></div></div></div><div id="alpha-slider" part="slider"><div id="alpha-slider-gradient"></div><div id="alpha-slider-track"><div id="alpha-slider-marker"></div></div></div></x-box></template>`; static #L = Tt`:host{display:block;width:100%;user-select:none;--wheel-max-width:none}:host([hidden]){display:none}#huesat-slider{display:flex;position:relative;width:100%;max-width:var(--wheel-max-width);margin:0 auto;height:auto;touch-action:pinch-zoom}#huesat-image{width:100%;height:100%;border-radius:999px;pointer-events:none}#huesat-marker{position:absolute;top:0;left:0;width:var(--marker-size);height:var(--marker-size);transform:translate(calc(var(--marker-size)/ -2),calc(var(--marker-size)/ -2));box-sizing:border-box;background:rgba(0,0,0,.3);border:3px solid #fff;border-radius:999px;box-shadow:0 0 3px #000;--marker-size:20px}#value-slider{width:100%;height:30px;margin-top:10px;padding:0 calc(var(--marker-width)/ 2);box-sizing:border-box;border-radius:2px;touch-action:pan-y;--marker-width:18px}:host([computedsize=small]) #value-slider{height:24px}:host([computedsize=large]) #value-slider{height:35px}#value-slider-track{width:100%;height:100%;position:relative;display:flex;align-items:center}#value-slider-marker{position:absolute;left:0;background:rgba(0,0,0,.2);box-shadow:0 0 3px #000;box-sizing:border-box;transform:translateX(calc((var(--marker-width)/ 2) * -1));border:3px solid #fff;width:var(--marker-width);height:calc(100% + 6px);position:absolute}#alpha-slider{position:relative;display:none;width:100%;height:30px;margin-top:14px;padding:0 calc(var(--marker-width)/ 2);box-sizing:border-box;border-radius:2px;touch-action:pan-y;--marker-width:18px;background-size:10px 10px;background-position:0 0,0 5px,5px -5px,-5px 0;background-image:linear-gradient(45deg,#d6d6d6 25%,transparent 25%),linear-gradient(-45deg,#d6d6d6 25%,transparent 25%),linear-gradient(45deg,transparent 75%,#d6d6d6 75%),linear-gradient(-45deg,transparent 75%,#d6d6d6 75%)}:host([alphaslider]) #alpha-slider{display:block}:host([computedsize=small]) #alpha-slider{height:24px}:host([computedsize=large]) #alpha-slider{height:35px}#alpha-slider-gradient{position:absolute;top:0;left:0;width:100%;height:100%}#alpha-slider-track{width:100%;height:100%;position:relative;display:flex;align-items:center}#alpha-slider-marker{position:absolute;left:0;background:rgba(0,0,0,.2);box-shadow:0 0 3px #000;box-sizing:border-box;transform:translateX(calc((var(--marker-width)/ 2) * -1));border:3px solid #fff;width:var(--marker-width);height:calc(100% + 6px);position:absolute}`; get value() { return this.hasAttribute("value") ? this.getAttribute("value") : "hsla(0, 0%, 100%, 1)" } set value(t) { this.setAttribute("value", t) } get size() { return this.hasAttribute("size") ? this.getAttribute("size") : null } set size(t) { null === t ? this.removeAttribute("size") : this.setAttribute("size", t) } get computedSize() { return this.hasAttribute("computedsize") ? this.getAttribute("computedsize") : "medium" } #T = null; #M = {}; #D = null; #j = 0; #H = 0; #Ti = 100; #q = 1; #gs = !1; #bs = !1; #Z = !1; constructor() { super(), this.#T = this.attachShadow({ mode: "closed" }), this.#T.adoptedStyleSheets = [Hi.#L], this.#T.append(document.importNode(Hi.#A.content, !0)); for (var t of this.#T.querySelectorAll("[id]")) this.#M[t.id] = t; this.#M["huesat-slider"].addEventListener("pointerdown", t => this.#fs(t)), this.#M["value-slider"].addEventListener("pointerdown", t => this.#xs(t)), this.#M["alpha-slider"].addEventListener("pointerdown", t => this.#_(t)) } async connectedCallback() { this.#J(), this.#F(), "" === this.#M["huesat-image"].src && (this.#M["huesat-image"].src = await z()), Me.addEventListener("sizechange", this.#D = () => this.#F()) } disconnectedCallback() { Me.removeEventListener("sizechange", this.#D) } attributeChangedCallback(t, e, i) { e !== i && ("value" === t ? this.#Q() : "size" === t && this.#tt()) } #J() { this.#ws(), this.#vs(), this.#ys(), this.#rt(), this.#ht() } #ws() { var t = this.#j, e = this.#H, t = n * t / 180, e = e / 100 * 100 / 2, i = (100 - (50 + e * Ni(t))) / 100 * 100, e = (50 - e * Bi(t)) / 100 * 100; this.#M["huesat-marker"].style.left = i + "%", this.#M["huesat-marker"].style.top = e + "%" } #vs() { this.#M["value-slider-marker"].style.left = 100 - h(this.#Ti, 0, 100, 2) + "%" } #ys() { var t = v([this.#j, this.#H, 100, 1], "hsva", "hex"); this.#M["value-slider"].style.background = "linear-gradient(to right, rgba(0,0,0,0), rgba(0,0,0,1)), " + t } #rt() { this.#M["alpha-slider-marker"].style.left = h(100 * (1 - this.#q), 0, 100, 2) + "%" } #ht() {
        var [t, e, i] = w(this.#j, this.#H, this.#Ti).map(t => o(t, 0)); this.#M["alpha-slider-gradient"].style.background = `
      linear-gradient(to right, rgba(${t}, ${e}, ${i}, 1), rgba(${t}, ${e}, ${i}, 0))
    `} #F() { var t = Me.size, e = this.size; "medium" === (t = null === e ? t : "smaller" === e ? "large" === t ? "medium" : "small" : "larger" === e ? "small" === t ? "medium" : "large" : e) ? this.removeAttribute("computedsize") : this.setAttribute("computedsize", t) } #Q() { var t, e, i, s; !1 === this.#gs && !1 === this.#bs && !1 === this.#Z && ([t, e, i, s] = (new E).parse(this.value, "hsva"), this.#j = t, this.#H = e, this.#Ti = i, this.#q = s, this.#J()) } #tt() { this.#F() } #fs(t) { if (!(1 < t.buttons)) { let e, i, l = this.#M["huesat-slider"].getBoundingClientRect(), s = (this.#gs = !0, this.dispatchEvent(new CustomEvent("changestart", { bubbles: !0 })), this.#M["huesat-slider"].style.cursor = "default", this.#M["huesat-slider"].setPointerCapture(t.pointerId), (t, e) => { let i = l.width / 2, s = t - l.left - i, r = e - l.top - i, n = ji(s, 2) + ji(r, 2), a = Fi(r, s); n > ji(i, 2) && (s = i * Ni(a), r = i * Bi(a), n = ji(s, 2) + ji(r, 2), a = Fi(r, s)), this.#j = o((a + Ii) / (2 * Ii) * 360, 3), this.#H = o(Oi(n) / i * 100, 3), this.value = v([this.#j, this.#H, this.#Ti, this.#q], "hsva", "hsla"), this.dispatchEvent(new CustomEvent("change", { bubbles: !0 })), this.#ws(), this.#ys(), this.#ht() }); s(t.clientX, t.clientY), this.#M["huesat-slider"].addEventListener("pointermove", e = t => { s(t.clientX, t.clientY) }), this.#M["huesat-slider"].addEventListener("pointerup", i = t => { this.#M["huesat-slider"].removeEventListener("pointermove", e), this.#M["huesat-slider"].removeEventListener("pointerup", i), this.#M["huesat-slider"].style.cursor = null, this.dispatchEvent(new CustomEvent("changeend", { bubbles: !0 })), this.#gs = !1 }) } } #xs(r) { if (!(1 < r.buttons)) { let t, e, i = this.#M["value-slider-track"].getBoundingClientRect(), s = (this.#bs = !0, this.#M["value-slider"].style.cursor = "default", this.#M["value-slider"].setPointerCapture(r.pointerId), this.dispatchEvent(new CustomEvent("changestart", { bubbles: !0 })), t => { t = 100 - (t - i.x) / i.width * 100; (t = h(t, 0, 100, 2)) !== this.#Ti && (this.#Ti = t, this.value = v([this.#j, this.#H, this.#Ti, this.#q], "hsva", "hsla"), this.#vs(), this.#ht(), this.dispatchEvent(new CustomEvent("change", { bubbles: !0 }))) }); s(r.clientX), this.#M["value-slider"].addEventListener("pointermove", t = t => { s(t.clientX) }), this.#M["value-slider"].addEventListener("pointerup", e = () => { this.#M["value-slider"].removeEventListener("pointermove", t), this.#M["value-slider"].removeEventListener("pointerup", e), this.#M["value-slider"].style.cursor = null, this.dispatchEvent(new CustomEvent("changeend", { bubbles: !0 })), this.#bs = !1 }) } } #_(r) { if (!(1 < r.buttons)) { let t, e, i = this.#M["alpha-slider-track"].getBoundingClientRect(), s = (this.#Z = !0, this.#M["alpha-slider"].style.cursor = "default", this.#M["alpha-slider"].setPointerCapture(r.pointerId), this.dispatchEvent(new CustomEvent("changestart", { bubbles: !0 })), t => { t = 1 - (t - i.x) / i.width; (t = h(t, 0, 1, 2)) !== this.#q && (this.#q = t, this.value = v([this.#j, this.#H, this.#Ti, this.#q], "hsva", "hsla"), this.#rt(), this.dispatchEvent(new CustomEvent("change", { bubbles: !0 }))) }); s(r.clientX), this.#M["alpha-slider"].addEventListener("pointermove", t = t => { s(t.clientX) }), this.#M["alpha-slider"].addEventListener("pointerup", e = () => { this.#M["alpha-slider"].removeEventListener("pointermove", t), this.#M["alpha-slider"].removeEventListener("pointerup", e), this.#M["alpha-slider"].style.cursor = null, this.dispatchEvent(new CustomEvent("changeend", { bubbles: !0 })), this.#Z = !1 }) } }
} customElements.define("x-wheelcolorpicker", Hi); export { Me as default };